// Generated by dts-bundle-generator v6.11.0

import { Renderer, Texture } from '@pixi/core';
import { Container } from '@pixi/display';
import { InteractionManager } from '@pixi/interaction';
import { Matrix, ObservablePoint, Point, Transform } from '@pixi/math';
import { Ticker } from '@pixi/ticker';
import { EventEmitter } from '@pixi/utils';

declare class Live2DModelWebGL {
	static loadModel(buffer: ArrayBuffer): Live2DModelWebGL;
	private constructor();
	drawParamWebGL: Live2DObfuscated.DrawParamWebGL;
	getModelContext(): Live2DObfuscated.ModelContext;
	/**
	 * @return The width of model's Live2D drawing canvas but NOT the html canvas element.
	 */
	getCanvasWidth(): number;
	/**
	 * @return The height of model's Live2D drawing canvas but NOT the html canvas element.
	 */
	getCanvasHeight(): number;
	setTexture(index: number, texture: WebGLTexture): void;
	setMatrix(matrix: ArrayLike<number>): void;
	setParamFloat(id: string | number, value: number, weight?: number): unknown;
	addToParamFloat(id: string | number, value: number, weight?: number): unknown;
	multParamFloat(id: string | number, value: number, weight?: number): unknown;
	setPartsOpacity(id: string | number, value: number): unknown;
	getPartsOpacity(id: string | number): number;
	getParamFloat(id: string | number): number;
	getParamIndex(id: string): number;
	getPartsDataIndex(id: string): number;
	getDrawDataIndex(id: string): number;
	getTransformedPoints(index: number): Float32Array;
	loadParam(): void;
	saveParam(): void;
	update(): void;
	draw(): void;
}
declare class AMotion {
	setFadeIn(time: number): unknown;
	setFadeOut(time: number): unknown;
	updateParam(model: Live2DModelWebGL, entry: Live2DObfuscated.MotionQueueEnt): void;
	updateParamExe(model: Live2DModelWebGL, time: number, weight: number, MotionQueueEnt: unknown): unknown;
}
declare class Live2DMotion extends AMotion {
	private constructor();
	static loadMotion(buffer: ArrayBuffer): Live2DMotion;
}
declare class MotionQueueManager {
	motions: unknown[];
	/**
	 * @return The size of internal motion arrays.
	 */
	startMotion(motion: AMotion, neverUsedArg?: boolean): number;
	stopAllMotions(): void;
	isFinished(): boolean;
	/**
	 * @return True if parameters are updated by any motion.
	 */
	updateParam(model: Live2DModelWebGL): boolean;
}
declare class PhysicsHair {
	static Src: {
		SRC_TO_X: string;
		SRC_TO_Y: string;
		SRC_TO_G_ANGLE: string;
	};
	static Target: {
		TARGET_FROM_ANGLE: string;
		TARGET_FROM_ANGLE_V: string;
	};
	setup(length: number, regist: number, mass: number): unknown;
	addSrcParam(type: string, id: string, scale: number, weight: number): unknown;
	addTargetParam(type: string, id: string, scale: number, weight: number): unknown;
	update(model: Live2DModelWebGL, time: number): unknown;
}
declare class DrawDataID {
	id: string;
}
/**
 * Members that have been obfuscated.
 */
export declare namespace Live2DObfuscated {
	class MotionQueueEnt {
		isFinished(): boolean;
	}
	class DrawParamWebGL {
		gl: WebGLRenderingContext;
		glno: number;
		firstDraw: boolean;
		culling: boolean;
		setGL(gl: WebGLRenderingContext): void;
	}
	class ModelContext {
		clipManager: ClipManager;
		/**
		 * This is basically `DrawData[]`, but not reliable since it's an obfuscated property.
		 * Always check the type before using it!
		 */
		_$aS?: unknown; // DrawData[]
		getDrawData(index: number): DrawData | null;
	}
	class IDrawData {
		getDrawDataID(): DrawDataID;
	}
	class DrawData extends IDrawData {
		getNumPoints?(): unknown;
		draw(aN: unknown, aK: unknown, aI: Unknown_aB): void;
	}
	class Unknown_aB {
		baseOpacity: number;
	}
	class ClipManager {
		curFrameNo: number;
		getMaskRenderTexture(): number;
		setupClip(modelContext: ModelContext, drawParam: DrawParamWebGL): void;
	}
}
/**
 * Copyright(c) Live2D Inc. All rights reserved.
 *
 * Use of this source code is governed by the Live2D Proprietary Software license
 * that can be found at https://www.live2d.com/eula/live2d-proprietary-software-license-agreement_en.html.
 */
export declare namespace Live2DCubismCore {
	/** Cubism version identifier. */
	type csmVersion = number;
	/** moc3 version identifier. */
	type csmMocVersion = number;
	/** Log handler.
	 *
	 * @param message Null-terminated string message to log.
	 */
	interface csmLogFunction {
		(message: string): void;
	}
	/** Cubism version. */
	class Version {
		/**
		 * Queries Core version.
		 *
		 * @return Core version.
		 */
		static csmGetVersion(): csmVersion;
		/**
		 * Gets Moc file supported latest version.
		 *
		 * @return Moc file latest format version.
		 */
		static csmGetLatestMocVersion(): csmMocVersion;
		/**
		 * Gets Moc file format version.
		 *
		 * @param moc Moc
		 *
		 * @return csmMocVersion
		 */
		static csmGetMocVersion(moc: Moc): csmMocVersion;
		private constructor();
	}
	/** Cubism logging. */
	class Logging {
		private static logFunction;
		/**
		 * Sets log handler.
		 *
		 * @param handler  Handler to use.
		 */
		static csmSetLogFunction(handler: csmLogFunction): void;
		/**
		 * Queries log handler.
		 *
		 * @return Log handler.
		 */
		static csmGetLogFunction(): csmLogFunction;
		/**
		 * Wrap log function.
		 *
		 * @param messagePtr number
		 *
		 * @return string
		 */
		private static wrapLogFunction;
		private constructor();
	}
	/** Cubism moc. */
	class Moc {
		/** Creates [[Moc]] from [[ArrayBuffer]].
		 *
		 * @param buffer Array buffer
		 *
		 * @return [[Moc]] on success; [[null]] otherwise.
		 */
		static fromArrayBuffer(buffer: ArrayBuffer): Moc;
		/** Releases instance. */
		_release(): void;
		/** Native moc. */
		_ptr: number;
		/**
		 * Initializes instance.
		 *
		 * @param mocBytes Moc bytes.
		 */
		private constructor();
	}
	/** Cubism model. */
	class Model {
		/** Parameters. */
		parameters: Parameters;
		/** Parts. */
		parts: Parts;
		/** Drawables. */
		drawables: Drawables;
		/** Canvas information. */
		canvasinfo: CanvasInfo;
		/**
		 * Creates [[Model]] from [[Moc]].
		 *
		 * @param moc Moc
		 *
		 * @return [[Model]] on success; [[null]] otherwise.
		 */
		static fromMoc(moc: Moc): Model;
		/** Updates instance. */
		update(): void;
		/** Releases instance. */
		release(): void;
		/** Native model. */
		_ptr: number;
		/**
		 * Initializes instance.
		 *
		 * @param moc Moc
		 */
		private constructor();
	}
	/** Canvas information interface. */
	class CanvasInfo {
		/** Width of native model canvas. */
		CanvasWidth: number;
		/** Height of native model canvas. */
		CanvasHeight: number;
		/** Coordinate origin of X axis. */
		CanvasOriginX: number;
		/** Coordinate origin of Y axis. */
		CanvasOriginY: number;
		/** Pixels per unit of native model. */
		PixelsPerUnit: number;
		/**
		 * Initializes instance.
		 *
		 * @param modelPtr Native model pointer.
		 */
		constructor(modelPtr: number);
	}
	/** Cubism model parameters */
	class Parameters {
		/** Parameter count. */
		count: number;
		/** Parameter IDs. */
		ids: Array<string>;
		/** Minimum parameter values. */
		minimumValues: Float32Array;
		/** Maximum parameter values. */
		maximumValues: Float32Array;
		/** Default parameter values. */
		defaultValues: Float32Array;
		/** Parameter values. */
		values: Float32Array;
		/**
		 * Initializes instance.
		 *
		 * @param modelPtr Native model.
		 */
		constructor(modelPtr: number);
	}
	/** Cubism model parts */
	class Parts {
		/** Part count. */
		count: number;
		/** Part IDs. */
		ids: Array<string>;
		/** Opacity values. */
		opacities: Float32Array;
		/** Part's parent part indices. */
		parentIndices: Int32Array;
		/**
		 * Initializes instance.
		 *
		 * @param modelPtr Native model.
		 */
		constructor(modelPtr: number);
	}
	/** Cubism model drawables */
	class Drawables {
		/** Drawable count. */
		count: number;
		/** Drawable IDs. */
		ids: Array<string>;
		/** Constant drawable flags. */
		constantFlags: Uint8Array;
		/** Dynamic drawable flags. */
		dynamicFlags: Uint8Array;
		/** Drawable texture indices. */
		textureIndices: Int32Array;
		/** Drawable draw orders. */
		drawOrders: Int32Array;
		/** Drawable render orders. */
		renderOrders: Int32Array;
		/** Drawable opacities. */
		opacities: Float32Array;
		/** Mask count for each drawable. */
		maskCounts: Int32Array;
		/** Masks for each drawable. */
		masks: Array<Int32Array>;
		/** Number of vertices of each drawable. */
		vertexCounts: Int32Array;
		/** 2D vertex position data of each drawable. */
		vertexPositions: Array<Float32Array>;
		/** 2D texture coordinate data of each drawables. */
		vertexUvs: Array<Float32Array>;
		/** Number of triangle indices for each drawable. */
		indexCounts: Int32Array;
		/** Triangle index data for each drawable. */
		indices: Array<Uint16Array>;
		/** Resets all dynamic drawable flags.. */
		resetDynamicFlags(): void;
		/** Native model. */
		private _modelPtr;
		/**
		 * Initializes instance.
		 *
		 * @param modelPtr Native model.
		 */
		constructor(modelPtr: number);
	}
	/** Utility functions. */
	class Utils {
		/**
		 * Checks whether flag is set in bitfield.
		 *
		 * @param bitfield Bitfield to query against.
		 *
		 * @return [[true]] if bit set; [[false]] otherwise
		*/
		static hasBlendAdditiveBit(bitfield: number): boolean;
		/**
		 * Checks whether flag is set in bitfield.
		 *
		 * @param bitfield Bitfield to query against.
		 *
		 * @return [[true]] if bit set; [[false]] otherwise
		*/
		static hasBlendMultiplicativeBit(bitfield: number): boolean;
		/**
		 * Checks whether flag is set in bitfield.
		 *
		 * @param bitfield Bitfield to query against.
		 *
		 * @return [[true]] if bit set; [[false]] otherwise
		*/
		static hasIsDoubleSidedBit(bitfield: number): boolean;
		/**
		 * Checks whether flag is set in bitfield.
		 *
		 * @param bitfield Bitfield to query against.
		 *
		 * @return [[true]] if bit set; [[false]] otherwise
		*/
		static hasIsInvertedMaskBit(bitfield: number): boolean;
		/**
		 * Checks whether flag is set in bitfield.
		 *
		 * @param bitfield Bitfield to query against.
		 *
		 * @return [[true]] if bit set; [[false]] otherwise
		*/
		static hasIsVisibleBit(bitfield: number): boolean;
		/**
		 * Checks whether flag is set in bitfield.
		 *
		 * @param bitfield Bitfield to query against.
		 *
		 * @return [[true]] if bit set; [[false]] otherwise
		*/
		static hasVisibilityDidChangeBit(bitfield: number): boolean;
		/**
		 * Checks whether flag is set in bitfield.
		 *
		 * @param bitfield Bitfield to query against.
		 *
		 * @return [[true]] if bit set; [[false]] otherwise
		*/
		static hasOpacityDidChangeBit(bitfield: number): boolean;
		/**
		 * Checks whether flag is set in bitfield.
		 *
		 * @param bitfield Bitfield to query against.
		 *
		 * @return [[true]] if bit set; [[false]] otherwise
		*/
		static hasDrawOrderDidChangeBit(bitfield: number): boolean;
		/**
		 * Checks whether flag is set in bitfield.
		 *
		 * @param bitfield Bitfield to query against.
		 *
		 * @return [[true]] if bit set; [[false]] otherwise
		*/
		static hasRenderOrderDidChangeBit(bitfield: number): boolean;
		/**
		 * Checks whether flag is set in bitfield.
		 *
		 * @param bitfield Bitfield to query against.
		 *
		 * @return [[true]] if bit set; [[false]] otherwise
		*/
		static hasVertexPositionsDidChangeBit(bitfield: number): boolean;
	}
	/** Emscripten Cubism Core module. */
}
export declare const LOGICAL_WIDTH = 2;
export declare const LOGICAL_HEIGHT = 2;
export type JSONObject = object;
export type Mutable<T> = {
	-readonly [P in keyof T]: T[P];
};
/**
 * Parses, and provides access to the settings JSON.
 */
export declare abstract class ModelSettings {
	json: JSONObject;
	/**
	 * The model's name, typically used for displaying or logging. By default it's inferred from
	 * the URL by taking the folder name (the second to last component). In Cubism 2 it'll be overwritten
	 * by the `name` field of settings JSON.
	 */
	name: string;
	/**
	 * URL of the model settings file, used to resolve paths of the resource files defined in settings.
	 * This typically ends with `.model.json` in Cubism 2 and `.model3.json` in Cubism 4.
	 */
	url: string;
	/**
	 * Relative path of he moc file, typically ends with `.moc` in Cubism 2 and `.moc3` in Cubism 4.
	 */
	abstract moc: string;
	/**
	 * Relative paths of the texture images.
	 */
	abstract textures: string[];
	/**
	 * Relative path of the pose file.
	 */
	pose?: string;
	/**
	 * Relative path of the physics file.
	 */
	physics?: string;
	/**
	 * @param json - The settings JSON object.
	 * @param json.url - The `url` field must be defined to specify the settings file's URL.
	 */
	protected constructor(json: JSONObject & {
		url: string;
	});
	/**
	 * Resolves a relative path using the {@link url}. This is used to resolve the resource files
	 * defined in the settings.
	 * @param path - Relative path.
	 * @return Resolved path.
	 */
	resolveURL(path: string): string;
	/**
	 * Replaces the resource files by running each file through the `replacer`.
	 * @param replacer - Invoked with two arguments: `(file, path)`, where `file` is the file definition,
	 * and `path` is its property path in the ModelSettings instance. A string must be returned to be the replacement.
	 *
	 * ```js
	 * modelSettings.replaceFiles((file, path) => {
	 *     // file = "foo.moc", path = "moc"
	 *     // file = "foo.png", path = "textures[0]"
	 *     // file = "foo.mtn", path = "motions.idle[0].file"
	 *     // file = "foo.motion3.json", path = "motions.idle[0].File"
	 *
	 *     return "bar/" + file;
	 * });
	 * ```
	 */
	replaceFiles(replacer: (file: string, path: string) => string): void;
	/**
	 * Retrieves all resource files defined in the settings.
	 * @return A flat array of the paths of all resource files.
	 *
	 * ```js
	 * modelSettings.getDefinedFiles();
	 * // returns: ["foo.moc", "foo.png", ...]
	 * ```
	 */
	getDefinedFiles(): string[];
	/**
	 * Validates that the files defined in the settings exist in given files. Each file will be
	 * resolved by {@link resolveURL} before comparison.
	 * @param files - A flat array of file paths.
	 * @return All the files which are defined in the settings and also exist in given files,
	 * *including the optional files*.
	 * @throws Error if any *essential* file is defined in settings but not included in given files.
	 */
	validateFiles(files: string[]): string[];
}
/**
 * Indicates the motion priority.
 */
export declare enum MotionPriority {
	/** States that the model is currently not playing any motion. This priority cannot be applied to a motion. */
	NONE = 0,
	/** Low priority, used when starting idle motions automatically. */
	IDLE = 1,
	/** Medium priority. */
	NORMAL = 2,
	/** High priority. Motions as this priority will always be played regardless of the current priority. */
	FORCE = 3
}
/**
 * Handles the state of a MotionManager.
 */
export declare class MotionState {
	/**
	 * Tag for logging.
	 */
	tag: string;
	/**
	 * When enabled, the states will be dumped to the logger when an exception occurs.
	 */
	debug: boolean;
	/**
	 * Priority of the current motion. Will be `MotionPriority.NONE` if there's no playing motion.
	 */
	currentPriority: MotionPriority;
	/**
	 * Priority of the reserved motion, which is still in loading and will be played once loaded.
	 * Will be `MotionPriority.NONE` if there's no reserved motion.
	 */
	reservePriority: MotionPriority;
	/**
	 * Group of current motion.
	 */
	currentGroup?: string;
	/**
	 * Index of current motion in its group.
	 */
	currentIndex?: number;
	/**
	 * Group of the reserved motion.
	 */
	reservedGroup?: string;
	/**
	 * Index of the reserved motion in its group.
	 */
	reservedIndex?: number;
	/**
	 * Group of the reserved idle motion.
	 */
	reservedIdleGroup?: string;
	/**
	 * Index of the reserved idle motion in its group.
	 */
	reservedIdleIndex?: number;
	/**
	 * Reserves the playback for a motion.
	 * @param group - The motion group.
	 * @param index - Index in the motion group.
	 * @param priority - The priority to be applied.
	 * @return True if the reserving has succeeded.
	 */
	reserve(group: string, index: number, priority: MotionPriority): boolean;
	/**
	 * Requests the playback for a motion.
	 * @param motion - The Motion, can be undefined.
	 * @param group - The motion group.
	 * @param index - Index in the motion group.
	 * @param priority - The priority to be applied.
	 * @return True if the request has been approved, i.e. the motion is allowed to play.
	 */
	start(motion: any, group: string, index: number, priority: MotionPriority): boolean;
	/**
	 * Notifies the motion playback has finished.
	 */
	complete(): void;
	/**
	 * Sets the current motion.
	 */
	setCurrent(group: string | undefined, index: number | undefined, priority: MotionPriority): void;
	/**
	 * Sets the reserved motion.
	 */
	setReserved(group: string | undefined, index: number | undefined, priority: MotionPriority): void;
	/**
	 * Sets the reserved idle motion.
	 */
	setReservedIdle(group: string | undefined, index: number | undefined): void;
	/**
	 * Checks if a Motion is currently playing or has reserved.
	 * @return True if active.
	 */
	isActive(group: string, index: number): boolean;
	/**
	 * Resets the state.
	 */
	reset(): void;
	/**
	 * Checks if an idle motion should be requests to play.
	 */
	shouldRequestIdleMotion(): boolean;
	/**
	 * Checks if the model's expression should be overridden by the motion.
	 */
	shouldOverrideExpression(): boolean;
	/**
	 * Dumps the state for debugging.
	 */
	dump(requestedGroup?: string, requestedIndex?: number): string;
}
export interface MotionManagerOptions {
	/**
	 * How to preload the motions.
	 * @default {@link MotionPreloadStrategy.NONE}
	 */
	motionPreload?: MotionPreloadStrategy;
	/**
	 * Specifies the idle motion group.
	 * @default "idle" in Cubism 2 and "Idle" in Cubism 4.
	 */
	idleMotionGroup?: string;
}
/**
 * Indicates how the motions will be preloaded.
 */
export declare enum MotionPreloadStrategy {
	/** Preload all the motions. */
	ALL = "ALL",
	/** Preload only the idle motions. */
	IDLE = "IDLE",
	/** No preload. */
	NONE = "NONE"
}
/**
 * Handles the motion playback.
 * @emits {@link MotionManagerEvents}
 */
export declare abstract class MotionManager<Motion = any, MotionSpec = any> extends EventEmitter {
	/**
	 * Tag for logging.
	 */
	tag: string;
	/**
	 * Motion definitions copied from ModelSettings.
	 */
	abstract readonly definitions: Partial<Record<string, MotionSpec[]>>;
	/**
	 * Motion groups with particular internal usages. Currently there's only the `idle` field,
	 * which specifies the actual name of the idle motion group, so the idle motions
	 * can be correctly found from the settings JSON of various Cubism versions.
	 */
	abstract readonly groups: {
		idle: string;
	};
	/**
	 * Indicates the content type of the motion files, varies in different Cubism versions.
	 * This will be used as `xhr.responseType`.
	 */
	abstract readonly motionDataType: "json" | "arraybuffer";
	/**
	 * Can be undefined if the settings defines no expression.
	 */
	abstract expressionManager?: ExpressionManager;
	/**
	 * The ModelSettings reference.
	 */
	readonly settings: ModelSettings;
	/**
	 * The Motions. The structure is the same as {@link definitions}, initially each group contains
	 * an empty array, which means all motions will be `undefined`. When a Motion has been loaded,
	 * it'll fill the place in which it should be; when it fails to load, the place will be filled
	 * with `null`.
	 */
	motionGroups: Partial<Record<string, (Motion | undefined | null)[]>>;
	/**
	 * Maintains the state of this MotionManager.
	 */
	state: MotionState;
	/**
	 * Audio element of the current motion if a sound file is defined with it.
	 */
	currentAudio?: HTMLAudioElement;
	/**
	 * Analyzer element for the current sound being played.
	 */
	currentAnalyzer?: AnalyserNode;
	/**
	 * Context element for the current sound being played.
	 */
	currentContext?: AudioContext;
	/**
	 * Flags there's a motion playing.
	 */
	playing: boolean;
	/**
	 * Flags the instances has been destroyed.
	 */
	destroyed: boolean;
	protected constructor(settings: ModelSettings, options?: MotionManagerOptions);
	/**
	 * Should be called in the constructor of derived class.
	 */
	protected init(options?: MotionManagerOptions): void;
	/**
	 * Sets up motions from the definitions, and preloads them according to the preload strategy.
	 */
	protected setupMotions(options?: MotionManagerOptions): void;
	/**
	 * Loads a Motion in a motion group. Errors in this method will not be thrown,
	 * but be emitted with a "motionLoadError" event.
	 * @param group - The motion group.
	 * @param index - Index in the motion group.
	 * @return Promise that resolves with the Motion, or with undefined if it can't be loaded.
	 * @emits {@link MotionManagerEvents.motionLoaded}
	 * @emits {@link MotionManagerEvents.motionLoadError}
	 */
	loadMotion(group: string, index: number): Promise<Motion | undefined>;
	/**
	 * Loads the Motion. Will be implemented by Live2DFactory in order to avoid circular dependency.
	 * @ignore
	 */
	private _loadMotion;
	/**
	 * Starts a motion as given priority.
	 * @param group - The motion group.
	 * @param index - Index in the motion group.
	 * @param priority - The priority to be applied.
	 * @param sound - The wav url file or base64 content
	 * @return Promise that resolves with true if the motion is successfully started, with false otherwise.
	 */
	startMotion(group: string, index: number, priority?: MotionPriority, sound?: string): Promise<boolean>;
	/**
	 * Starts a random Motion as given priority.
	 * @param group - The motion group.
	 * @param priority - The priority to be applied.
	 * @param sound - The wav url file or base64 content
	 * @return Promise that resolves with true if the motion is successfully started, with false otherwise.
	 */
	startRandomMotion(group: string, priority?: MotionPriority, sound?: string): Promise<boolean>;
	/**
	 * Stops all playing motions as well as the sound.
	 */
	stopAllMotions(): void;
	/**
	 * Updates parameters of the core model.
	 * @param model - The core model.
	 * @param now - Current time in milliseconds.
	 * @return True if the parameters have been actually updated.
	 */
	update(model: object, now: DOMHighResTimeStamp): boolean;
	/**
	 * Move the mouth
	 *
	 */
	mouthSync(): number;
	/**
	 * Destroys the instance.
	 * @emits {@link MotionManagerEvents.destroy}
	 */
	destroy(): void;
	/**
	 * Checks if the motion playback has finished.
	 */
	abstract isFinished(): boolean;
	/**
	 * Creates a Motion from the data.
	 * @param data - Content of the motion file. The format must be consistent with {@link MotionManager#motionDataType}.
	 * @param group - The motion group.
	 * @param definition - The motion definition.
	 * @return The created Motion.
	 */
	abstract createMotion(data: ArrayBuffer | JSONObject, group: string, definition: MotionSpec): Motion;
	/**
	 * Retrieves the motion's file path by its definition.
	 * @return The file path extracted from given definition. Not resolved.
	 */
	abstract getMotionFile(definition: MotionSpec): string;
	/**
	 * Retrieves the motion's name by its definition.
	 * @return The motion's name.
	 */
	protected abstract getMotionName(definition: MotionSpec): string;
	/**
	 * Retrieves the motion's sound file by its definition.
	 * @return The motion's sound file, can be undefined.
	 */
	protected abstract getSoundFile(definition: MotionSpec): string | undefined;
	/**
	 * Starts the Motion.
	 */
	protected abstract _startMotion(motion: Motion, onFinish?: (motion: Motion) => void): number;
	/**
	 * Stops all playing motions.
	 */
	protected abstract _stopAllMotions(): void;
	/**
	 * Updates parameters of the core model.
	 * @param model - The core model.
	 * @param now - Current time in milliseconds.
	 * @return True if the parameters have been actually updated.
	 */
	protected abstract updateParameters(model: object, now: DOMHighResTimeStamp): boolean;
}
export interface Live2DModelEvents {
	/**
	 * @event - One or more hit areas are hit.
	 * @param - The names of *hit* hit areas.
	 */
	hit: [
		string[]
	];
	/**
	 * @event - The settings JSON has been loaded.
	 * @param - The settings JSON object.
	 */
	settingsJSONLoaded: [
		JSONObject
	];
	/**
	 * @event - The ModelSettings has been loaded.
	 * @param - The ModelSettings instance.
	 */
	settingsLoaded: [
		ModelSettings
	];
	/**
	 * @event - The textures have all been loaded.
	 * @param - The texture array.
	 */
	textureLoaded: [
		Texture[]
	];
	/**
	 * @event - The InternalModel has been loaded.
	 * @param - The InternalModel instance.
	 */
	modelLoaded: [
		InternalModel
	];
	/**
	 * @event - The Pose has been loaded.
	 * @param - The Pose instance, varies in different Cubism version.
	 */
	poseLoaded: [
		unknown
	];
	/**
	 * @event - The Physics has been loaded.
	 * @param - The Physics instance, varies in different Cubism version.
	 */
	physicsLoaded: [
		unknown
	];
	/**
	 * @event - All the essential resources have been loaded.
	 */
	ready: [
	];
	/**
	 * @event - All the resources have been loaded.
	 */
	load: [
	];
}
export interface MotionManagerEvents<Motion = any> {
	/**
	 * @event - A Motion has been loaded.
	 * @param - The Motion instance, varies in different Cubism version.
	 */
	motionLoaded: [
		Motion
	];
	/**
	 * @event - An error occurs when loading a Motion.
	 * @param - The error.
	 */
	motionLoadError: [
		unknown
	];
	/**
	 * @event - Before destroyed.
	 */
	destroy: [
	];
}
export interface ExpressionManagerEvents<Expression = any> {
	/**
	 * @event - An Expression has been loaded.
	 * @param - The Expression instance, varies in different Cubism version.
	 */
	expressionLoaded: [
		Expression
	];
	/**
	 * @event - An error occurs when loading an Expression.
	 * @param - The error.
	 */
	expressionLoadError: [
		unknown
	];
	/**
	 * @event - Before destroyed.
	 */
	destroy: [
	];
}
export interface InternalModelEvents {
	/**
	 * @event - Before the model's parameters are updated by the motion.
	 */
	beforeMotionUpdate: [
	];
	/**
	 * @event - After the model's parameters are updated by the motion.
	 */
	afterMotionUpdate: [
	];
	/**
	 * @event - Before the model is updated with its parameters applied.
	 */
	beforeModelUpdate: [
	];
	/**
	 * @event - Before destroyed.
	 */
	destroy: [
	];
}
/**
 * Abstract expression manager.
 * @emits {@link ExpressionManagerEvents}
 */
export declare abstract class ExpressionManager<Expression = any, ExpressionSpec = any> extends EventEmitter<keyof ExpressionManagerEvents> {
	/**
	 * Tag for logging.
	 */
	tag: string;
	/**
	 * Expression definitions copied from ModelSettings.
	 */
	abstract readonly definitions: ExpressionSpec[];
	/**
	 * The ModelSettings reference.
	 */
	readonly settings: ModelSettings;
	/**
	 * The Expressions. The structure is the same as {@link definitions}, initially there's only
	 * an empty array, which means all expressions will be `undefined`. When an Expression has
	 * been loaded, it'll fill the place in which it should be; when it fails to load,
	 * the place will be filled with `null`.
	 */
	expressions: (Expression | null | undefined)[];
	/**
	 * An empty Expression to reset all the expression parameters.
	 */
	defaultExpression: Expression;
	/**
	 * Current Expression. This will not be overwritten by {@link ExpressionManager#defaultExpression}.
	 */
	currentExpression: Expression;
	/**
	 * The pending Expression.
	 */
	reserveExpressionIndex: number;
	/**
	 * Flags the instance has been destroyed.
	 */
	destroyed: boolean;
	protected constructor(settings: ModelSettings, options?: MotionManagerOptions);
	/**
	 * Should be called in the constructor of derived class.
	 */
	protected init(): void;
	/**
	 * Loads an Expression. Errors in this method will not be thrown,
	 * but be emitted with an "expressionLoadError" event.
	 * @param index - Index of the expression in definitions.
	 * @return Promise that resolves with the Expression, or with undefined if it can't be loaded.
	 * @emits {@link ExpressionManagerEvents.expressionLoaded}
	 * @emits {@link ExpressionManagerEvents.expressionLoadError}
	 */
	protected loadExpression(index: number): Promise<Expression | undefined>;
	/**
	 * Loads the Expression. Will be implemented by Live2DFactory in order to avoid circular dependency.
	 * @ignore
	 */
	private _loadExpression;
	/**
	 * Sets a random Expression that differs from current one.
	 * @return Promise that resolves with true if succeeded, with false otherwise.
	 */
	setRandomExpression(): Promise<boolean>;
	/**
	 * Resets model's expression using {@link ExpressionManager#defaultExpression}.
	 */
	resetExpression(): void;
	/**
	 * Restores model's expression to {@link currentExpression}.
	 */
	restoreExpression(): void;
	/**
	 * Sets an Expression.
	 * @param index - Either the index, or the name of the expression.
	 * @return Promise that resolves with true if succeeded, with false otherwise.
	 */
	setExpression(index: number | string): Promise<boolean>;
	/**
	 * Updates parameters of the core model.
	 * @return True if the parameters are actually updated.
	 */
	update(model: object, now: DOMHighResTimeStamp): boolean;
	/**
	 * Destroys the instance.
	 * @emits {@link ExpressionManagerEvents.destroy}
	 */
	destroy(): void;
	/**
	 * Checks if the expression playback has finished.
	 */
	abstract isFinished(): boolean;
	/**
	 * Retrieves the expression's index by its name.
	 * @return The index. `-1` if not found.
	 */
	abstract getExpressionIndex(name: string): number;
	/**
	 * Retrieves the expression's file path by its definition.
	 * @return The file path extracted from given definition. Not resolved.
	 */
	abstract getExpressionFile(definition: ExpressionSpec): string;
	/**
	 * Creates an Expression from the data.
	 * @param data - Content of the expression file.
	 * @param definition - The expression definition. Can be undefined in order to create {@link ExpressionManager#defaultExpression}.
	 * @return The created Expression.
	 */
	abstract createExpression(data: JSONObject, definition: ExpressionSpec | undefined): Expression;
	/**
	 * Applies the Expression to the model.
	 */
	protected abstract _setExpression(motion: Expression): number;
	/**
	 * Cancels expression playback.
	 */
	protected abstract stopAllExpressions(): void;
	/**
	 * Updates parameters of the core model.
	 * @return True if the parameters are actually updated.
	 */
	protected abstract updateParameters(model: object, now: DOMHighResTimeStamp): boolean;
}
/**
 * Interpolates the transition of focus position.
 */
export declare class FocusController {
	/** The focus position. */
	targetX: number;
	/** The focus position. */
	targetY: number;
	/** Current position. */
	x: number;
	/** Current position. */
	y: number;
	/** Current velocity. */
	vx: number;
	/** Current velocity. */
	vy: number;
	/**
	 * Sets the focus position.
	 * @param x - X position in range `[-1, 1]`.
	 * @param y - Y position in range `[-1, 1]`.
	 * @param instant - Should the focus position be instantly applied.
	 */
	focus(x: number, y: number, instant?: boolean): void;
	/**
	 * Updates the interpolation.
	 * @param dt - Delta time in milliseconds.
	 */
	update(dt: DOMHighResTimeStamp): void;
}
/**
 * Manages all the sounds.
 */
export declare class SoundManager {
	/**
	 * Audio elements playing or pending to play. Finished audios will be removed automatically.
	 */
	static audios: HTMLAudioElement[];
	static analysers: AnalyserNode[];
	static contexts: AudioContext[];
	protected static _volume: number;
	/**
	 * Global volume that applies to all the sounds.
	 */
	static get volume(): number;
	static set volume(value: number);
	/**
	 * Creates an audio element and adds it to the {@link audios}.
	 * @param file - URL of the sound file.
	 * @param onFinish - Callback invoked when the playback has finished.
	 * @param onError - Callback invoked when error occurs.
	 * @return Created audio element.
	 */
	static add(file: string, onFinish?: () => void, onError?: (e: Error) => void): HTMLAudioElement;
	/**
	 * Plays the sound.
	 * @param audio - An audio element.
	 * @return Promise that resolves when the audio is ready to play, rejects when error occurs.
	 */
	static play(audio: HTMLAudioElement): Promise<void>;
	static addContext(audio: HTMLAudioElement): AudioContext;
	static addAnalyzer(audio: HTMLAudioElement, context: AudioContext): AnalyserNode;
	/**
	 * Get volume for lip sync
	 * @param analyser - An analyzer element.
	 * @return Returns value to feed into lip sync
	 */
	static analyze(analyser: AnalyserNode): number;
	/**
	 * Disposes an audio element and removes it from {@link audios}.
	 * @param audio - An audio element.
	 */
	static dispose(audio: HTMLAudioElement): void;
	/**
	 * Destroys all managed audios.
	 */
	static destroy(): void;
}
/**
 * Common layout definition shared between all Cubism versions.
 */
export interface CommonLayout {
	centerX?: number;
	centerY?: number;
	x?: number;
	y?: number;
	width?: number;
	height?: number;
	top?: number;
	bottom?: number;
	left?: number;
	right?: number;
}
/**
 * Common hit area definition shared between all Cubism versions.
 */
export interface CommonHitArea {
	id: string;
	name: string;
	index: number;
}
export interface Bounds {
	x: number;
	y: number;
	width: number;
	height: number;
}
export interface InternalModelOptions extends MotionManagerOptions {
}
/**
 * A wrapper that manages the states of a Live2D core model, and delegates all operations to it.
 * @emits {@link InternalModelEvents}
 */
export declare abstract class InternalModel extends EventEmitter {
	/**
	 * The managed Live2D core model.
	 */
	abstract readonly coreModel: object;
	abstract readonly settings: ModelSettings;
	focusController: FocusController;
	abstract motionManager: MotionManager;
	pose?: any;
	physics?: any;
	/**
	 * Original canvas width of the model. Note this doesn't represent the model's real size,
	 * as the model can overflow from its canvas.
	 */
	readonly originalWidth: number;
	/**
	 * Original canvas height of the model. Note this doesn't represent the model's real size,
	 * as the model can overflow from its canvas.
	 */
	readonly originalHeight: number;
	/**
	 * Canvas width of the model, scaled by the `width` of the model's layout.
	 */
	readonly width: number;
	/**
	 * Canvas height of the model, scaled by the `height` of the model's layout.
	 */
	readonly height: number;
	/**
	 * Local transformation, calculated from the model's layout.
	 */
	localTransform: Matrix;
	/**
	 * The final matrix to draw the model.
	 */
	drawingMatrix: Matrix;
	/**
	 * The hit area definitions, keyed by their names.
	 */
	hitAreas: Record<string, CommonHitArea>;
	/**
	 * Flags whether `gl.UNPACK_FLIP_Y_WEBGL` should be enabled when binding the textures.
	 */
	textureFlipY: boolean;
	/**
	 * WebGL viewport when drawing the model. The format is `[x, y, width, height]`.
	 */
	viewport: [
		number,
		number,
		number,
		number
	];
	/**
	 * Flags this instance has been destroyed.
	 */
	destroyed: boolean;
	/**
	 * Should be called in the constructor of derived class.
	 */
	protected init(): void;
	/**
	 * Sets up the model's size and local transform by the model's layout.
	 */
	protected setupLayout(): void;
	/**
	 * Sets up the hit areas by their definitions in settings.
	 */
	protected setupHitAreas(): void;
	/**
	 * Hit-test on the model.
	 * @param x - Position in model canvas.
	 * @param y - Position in model canvas.
	 * @return The names of the *hit* hit areas. Can be empty if none is hit.
	 */
	hitTest(x: number, y: number): string[];
	/**
	 * Hit-test for a single hit area.
	 * @param hitAreaName - The hit area's name.
	 * @param x - Position in model canvas.
	 * @param y - Position in model canvas.
	 * @return True if hit.
	 */
	isHit(hitAreaName: string, x: number, y: number): boolean;
	/**
	 * Gets a drawable's bounds.
	 * @param index - Index of the drawable.
	 * @param bounds - Object to store the output values.
	 * @return The bounds in model canvas space.
	 */
	getDrawableBounds(index: number, bounds?: Bounds): Bounds;
	/**
	 * Updates the model's transform.
	 * @param transform - The world transform.
	 */
	updateTransform(transform: Matrix): void;
	/**
	 * Updates the model's parameters.
	 * @param dt - Elapsed time in milliseconds from last frame.
	 * @param now - Current time in milliseconds.
	 */
	update(dt: DOMHighResTimeStamp, now: DOMHighResTimeStamp): void;
	/**
	 * Destroys the model and all related resources.
	 * @emits {@link InternalModelEvents.destroy | destroy}
	 */
	destroy(): void;
	/**
	 * Gets all the hit area definitions.
	 * @return Normalized definitions.
	 */
	protected abstract getHitAreaDefs(): CommonHitArea[];
	/**
	 * Gets the model's original canvas size.
	 * @return `[width, height]`
	 */
	protected abstract getSize(): [
		number,
		number
	];
	/**
	 * Gets the layout definition.
	 * @return Normalized definition.
	 */
	protected abstract getLayout(): CommonLayout;
	/**
	 * Gets all the drawables' IDs.
	 * @return IDs.
	 */
	abstract getDrawableIDs(): string[];
	/**
	 * Finds the index of a drawable by its ID.
	 * @return The index.
	 */
	abstract getDrawableIndex(id: string): number;
	/**
	 * Gets a drawable's vertices.
	 * @param index - Either the index or the ID of the drawable.
	 * @throws Error when the drawable cannot be found.
	 */
	abstract getDrawableVertices(index: number | string): Float32Array;
	/**
	 * Updates WebGL context bound to this model.
	 * @param gl - WebGL context.
	 * @param glContextID - Unique ID for given WebGL context.
	 */
	abstract updateWebGLContext(gl: WebGLRenderingContext, glContextID: number): void;
	/**
	 * Binds a texture to the model. The index must be the same as that of this texture
	 * in the {@link ModelSettings.textures} array.
	 */
	abstract bindTexture(index: number, texture: WebGLTexture): void;
	/**
	 * Draws the model.
	 */
	abstract draw(gl: WebGLRenderingContext): void;
}
export type Middleware<T> = (context: T, next: (err?: any) => Promise<void>) => Promise<void>;
export interface Live2DFactoryOptions extends Live2DModelOptions {
	/**
	 * String to use for crossOrigin properties on `<img>` elements when loading textures.
	 * @default undefined
	 */
	crossOrigin?: string;
	/**
	 * Callback invoked when the model has been loaded.
	 * @default undefined
	 */
	onLoad?(): void;
	/**
	 * Callback invoked when error occurs while loading the model.
	 * @default undefined
	 */
	onError?(e: Error): void;
}
/**
 * The context transferred through the model creation middlewares.
 */
export interface Live2DFactoryContext {
	source: any;
	options: Live2DFactoryOptions;
	live2dModel: Live2DModel;
	internalModel?: InternalModel;
	settings?: ModelSettings;
}
/**
 * Represents a Cubism version.
 */
export interface Live2DRuntime {
	/**
	 * The version number. Higher version takes priority when matching the runtime.
	 */
	version: number;
	/**
	 * Checks if the source belongs to this runtime.
	 * @param source - Either a settings JSON object or a ModelSettings instance.
	 * @return True if the source belongs to this runtime.
	 */
	test(source: any): boolean;
	ready(): Promise<void>;
	/**
	 * Checks if the data is a valid moc to create the core model.
	 * @param modelData - The moc content.
	 * @return True if the data is valid.
	 */
	isValidMoc(modelData: ArrayBuffer): boolean;
	/**
	 * Creates a ModelSettings.
	 * @param json - The settings JSON object.
	 * @return Created ModelSettings.
	 */
	createModelSettings(json: JSONObject): ModelSettings;
	/**
	 * Creates a core model.
	 * @param data - Content of the moc file.
	 * @return Created core model.
	 */
	createCoreModel(data: ArrayBuffer): any;
	/**
	 * Creates an InternalModel.
	 * @param coreModel - Core model that *must* belong to this runtime.
	 * @param settings - ModelSettings of this model.
	 * @param options - Options that will be passed to the InternalModel's constructor.
	 * @return Created InternalModel.
	 */
	createInternalModel(coreModel: any, settings: ModelSettings, options?: Live2DFactoryOptions): InternalModel;
	/**
	 * Creates a pose.
	 * @param coreModel - Core model that *must* belong to this runtime.
	 * @param data - Content of the pose file.
	 * @return Created pose.
	 */
	createPose(coreModel: any, data: any): any;
	/**
	 * Creates a physics.
	 * @param coreModel - Core model that *must* belong to this runtime.
	 * @param data - Content of the physics file.
	 * @return Created physics.
	 */
	createPhysics(coreModel: any, data: any): any;
}
/**
 * Handles all the network load tasks.
 *
 * - Model creation: requested by {@link Live2DModel.from}.
 * - Motion loading: implements the load method of MotionManager.
 * - Expression loading: implements the load method of ExpressionManager.
 */
export declare class Live2DFactory {
	/**
	 * All registered runtimes, sorted by versions in descending order.
	 */
	static runtimes: Live2DRuntime[];
	static urlToJSON: Middleware<Live2DFactoryContext>;
	static jsonToSettings: Middleware<Live2DFactoryContext>;
	static waitUntilReady: Middleware<Live2DFactoryContext>;
	static setupOptionals: Middleware<Live2DFactoryContext>;
	static setupEssentials: Middleware<Live2DFactoryContext>;
	static createInternalModel: Middleware<Live2DFactoryContext>;
	/**
	 * Middlewares to run through when setting up a Live2DModel.
	 */
	static live2DModelMiddlewares: Middleware<Live2DFactoryContext>[];
	/**
	 * load tasks of each motion. The structure of each value in this map
	 * is the same as respective {@link MotionManager.definitions}.
	 */
	static motionTasksMap: WeakMap<MotionManager<any, any>, Record<string, (Promise<any> | undefined)[]>>;
	/**
	 * Load tasks of each expression.
	 */
	static expressionTasksMap: WeakMap<ExpressionManager<any, any>, (Promise<any> | undefined)[]>;
	/**
	 * Registers a Live2DRuntime.
	 */
	static registerRuntime(runtime: Live2DRuntime): void;
	/**
	 * Finds a runtime that matches given source.
	 * @param source - Either a settings JSON object or a ModelSettings instance.
	 * @return The Live2DRuntime, or undefined if not found.
	 */
	static findRuntime(source: any): Live2DRuntime | undefined;
	/**
	 * Sets up a Live2DModel, populating it with all defined resources.
	 * @param live2dModel - The Live2DModel instance.
	 * @param source - Can be one of: settings file URL, settings JSON object, ModelSettings instance.
	 * @param options - Options for the process.
	 * @return Promise that resolves when all resources have been loaded, rejects when error occurs.
	 */
	static setupLive2DModel<IM extends InternalModel>(live2dModel: Live2DModel<IM>, source: string | object | IM["settings"], options?: Live2DFactoryOptions): Promise<void>;
	/**
	 * Loads a Motion and registers the task to {@link motionTasksMap}. The task will be automatically
	 * canceled when its owner - the MotionManager instance - has been destroyed.
	 * @param motionManager - MotionManager that owns this Motion.
	 * @param group - The motion group.
	 * @param index - Index in the motion group.
	 * @return Promise that resolves with the Motion, or with undefined if it can't be loaded.
	 */
	static loadMotion<Motion, MotionSpec>(motionManager: MotionManager<Motion, MotionSpec>, group: string, index: number): Promise<Motion | undefined>;
	/**
	 * Loads an Expression and registers the task to {@link expressionTasksMap}. The task will be automatically
	 * canceled when its owner - the ExpressionManager instance - has been destroyed.
	 * @param expressionManager - ExpressionManager that owns this Expression.
	 * @param index - Index of the Expression.
	 * @return Promise that resolves with the Expression, or with undefined if it can't be loaded.
	 */
	static loadExpression<Expression, ExpressionSpec>(expressionManager: ExpressionManager<Expression, ExpressionSpec>, index: number): Promise<Expression | undefined>;
	static releaseTasks(this: MotionManager | ExpressionManager): void;
}
/**
 * The interaction control split from Live2DModel class for code clarity. This mixin should *only*
 * be used on the Live2DModel.
 */
export declare class InteractionMixin {
	private _autoInteract;
	/**
	 * Enables automatic interaction. Only takes effect if Pixi's interaction
	 * feature has been enabled (by registering the `PIXI.InteractionManager` into `PIXI.Renderer`).
	 */
	get autoInteract(): boolean;
	set autoInteract(autoInteract: boolean);
	/**
	 * Local reference used to clean up the event listeners when destroying the model.
	 */
	interactionManager?: InteractionManager;
	/**
	 * Registers interaction by subscribing to the `PIXI.InteractionManager`.
	 */
	registerInteraction(this: Live2DModel<any>, manager?: InteractionManager): void;
	/**
	 * Unregisters interaction.
	 */
	unregisterInteraction(this: Live2DModel<any>): void;
}
/**
 * Useless class. May be useful in the future.
 */
export declare class Live2DTransform extends Transform {
}
export interface Live2DModelOptions extends MotionManagerOptions {
	/**
	 * Should the internal model be automatically updated by `PIXI.Ticker.shared`.
	 * @default ture
	 */
	autoUpdate?: boolean;
	/**
	 * Should the internal model automatically reacts to interactions by listening for pointer events.
	 * @see {@link InteractionMixin}
	 * @default true
	 */
	autoInteract?: boolean;
}
export type TickerClass = typeof Ticker;
export interface Live2DModel<IM extends InternalModel = InternalModel> extends InteractionMixin {
}
export type Live2DConstructor = {
	new (options?: Live2DModelOptions): Live2DModel;
};
/**
 * A wrapper that allows the Live2D model to be used as a DisplayObject in PixiJS.
 *
 * ```js
 * const model = await Live2DModel.from('shizuku.model.json');
 * container.add(model);
 * ```
 * @emits {@link Live2DModelEvents}
 */
export declare class Live2DModel<IM extends InternalModel = InternalModel> extends Container {
	/**
	 * Creates a Live2DModel from given source.
	 * @param source - Can be one of: settings file URL, settings JSON object, ModelSettings instance.
	 * @param options - Options for the creation.
	 * @return Promise that resolves with the Live2DModel.
	 */
	static from<M extends Live2DConstructor = typeof Live2DModel>(this: M, source: string | JSONObject | ModelSettings, options?: Live2DFactoryOptions): Promise<InstanceType<M>>;
	/**
	 * Synchronous version of `Live2DModel.from()`. This method immediately returns a Live2DModel instance,
	 * whose resources have not been loaded. Therefore this model can't be manipulated or rendered
	 * until the "load" event has been emitted.
	 *
	 * ```js
	 * // no `await` here as it's not a Promise
	 * const model = Live2DModel.fromSync('shizuku.model.json');
	 *
	 * // these will cause errors!
	 * // app.stage.addChild(model);
	 * // model.motion('tap_body');
	 *
	 * model.once('load', () => {
	 *     // now it's safe
	 *     app.stage.addChild(model);
	 *     model.motion('tap_body');
	 * });
	 * ```
	 */
	static fromSync<M extends Live2DConstructor = typeof Live2DModel>(this: M, source: string | JSONObject | ModelSettings, options?: Live2DFactoryOptions): InstanceType<M>;
	/**
	 * Registers the class of `PIXI.Ticker` for auto updating.
	 */
	static registerTicker(tickerClass: TickerClass): void;
	/**
	 * Tag for logging.
	 */
	tag: string;
	/**
	 * The internal model. Though typed as non-nullable, it'll be undefined until the "ready" event is emitted.
	 */
	internalModel: IM;
	/**
	 * Pixi textures.
	 */
	textures: Texture[];
	/** @override */
	transform: Live2DTransform;
	/**
	 * The anchor behaves like the one in `PIXI.Sprite`, where `(0, 0)` means the top left
	 * and `(1, 1)` means the bottom right.
	 */
	anchor: ObservablePoint<any>;
	/**
	 * An ID of Gl context that syncs with `renderer.CONTEXT_UID`. Used to check if the GL context has changed.
	 */
	protected glContextID: number;
	/**
	 * Elapsed time in milliseconds since created.
	 */
	elapsedTime: DOMHighResTimeStamp;
	/**
	 * Elapsed time in milliseconds from last frame to this frame.
	 */
	deltaTime: DOMHighResTimeStamp;
	/**
	 * True if the model has been updated at least once since created.
	 */
	wasUpdated: boolean;
	protected _autoUpdate: boolean;
	/**
	 * Enables automatic updating. Requires {@link Live2DModel.registerTicker} or the global `window.PIXI.Ticker`.
	 */
	get autoUpdate(): boolean;
	set autoUpdate(autoUpdate: boolean);
	constructor(options?: Live2DModelOptions);
	/**
	 * A handler of the "modelLoaded" event, invoked when the internal model has been loaded.
	 */
	protected init(options?: Live2DModelOptions): void;
	/**
	 * A callback that observes {@link anchor}, invoked when the anchor's values have been changed.
	 */
	protected onAnchorChange(): void;
	/**
	 * Shorthand to start a motion.
	 * @param group - The motion group.
	 * @param index - The index in this group. If not presented, a random motion will be started.
	 * @param priority - The motion priority. Defaults to `MotionPriority.NORMAL`.
	 * @param sound - The wav url file or base64 content
	 * @return Promise that resolves with true if the motion is successfully started, with false otherwise.
	 */
	motion(group: string, index?: number, priority?: MotionPriority, sound?: string): Promise<boolean>;
	/**
	 * Shorthand to set an expression.
	 * @param id - Either the index, or the name of the expression. If not presented, a random expression will be set.
	 * @return Promise that resolves with true if succeeded, with false otherwise.
	 */
	expression(id?: number | string): Promise<boolean>;
	/**
	 * Updates the focus position. This will not cause the model to immediately look at the position,
	 * instead the movement will be interpolated.
	 * @param x - Position in world space.
	 * @param y - Position in world space.
	 * @param instant - Should the focus position be instantly applied.
	 */
	focus(x: number, y: number, instant?: boolean): void;
	/**
	 * Tap on the model. This will perform a hit-testing, and emit a "hit" event
	 * if at least one of the hit areas is hit.
	 * @param x - Position in world space.
	 * @param y - Position in world space.
	 * @emits {@link Live2DModelEvents.hit}
	 */
	tap(x: number, y: number): void;
	/**
	 * Hit-test on the model.
	 * @param x - Position in world space.
	 * @param y - Position in world space.
	 * @return The names of the *hit* hit areas. Can be empty if none is hit.
	 */
	hitTest(x: number, y: number): string[];
	/**
	 * Calculates the position in the canvas of original, unscaled Live2D model.
	 * @param position - A Point in world space.
	 * @param result - A Point to store the new value. Defaults to a new Point.
	 * @param skipUpdate - True to skip the update transform.
	 * @return The Point in model canvas space.
	 */
	toModelPosition(position: Point, result?: Point, skipUpdate?: boolean): Point;
	/**
	 * A method required by `PIXI.InteractionManager` to perform hit-testing.
	 * @param point - A Point in world space.
	 * @return True if the point is inside this model.
	 */
	containsPoint(point: Point): boolean;
	/** @override */
	protected _calculateBounds(): void;
	/**
	 * An update callback to be added to `PIXI.Ticker` and invoked every tick.
	 */
	onTickerUpdate(): void;
	/**
	 * Updates the model. Note this method just updates the timer,
	 * and the actual update will be done right before rendering the model.
	 * @param dt - The elapsed time in milliseconds since last frame.
	 */
	update(dt: DOMHighResTimeStamp): void;
	_render(renderer: Renderer): void;
	/**
	 * Destroys the model and all related resources. This takes the same options and also
	 * behaves the same as `PIXI.Container#destroy`.
	 * @param options - Options parameter. A boolean will act as if all options
	 *  have been set to that value
	 * @param [options.children=false] - if set to true, all the children will have their destroy
	 *  method called as well. 'options' will be passed on to those calls.
	 * @param [options.texture=false] - Only used for child Sprites if options.children is set to true
	 *  Should it destroy the texture of the child sprite
	 * @param [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
	 *  Should it destroy the base texture of the child sprite
	 */
	destroy(options?: {
		children?: boolean;
		texture?: boolean;
		baseTexture?: boolean;
	}): void;
}
export declare namespace CubismConfig {
	/**
	 * Support 4x4 mask division, which is unofficial and experimental.
	 * @see https://docs.live2d.com/cubism-sdk-manual/ow-sdk-mask-premake-web/?locale=en_us
	 * @default true
	 */
	let supportMoreMaskDivisions: boolean;
	/**
	 * Set opacity values directly from motion curves, instead of getting the values calculated by Pose.
	 * This can prevent opacity values from being ignored when the model does not have a Pose.
	 * @see https://github.com/guansss/CubismWebFramework/pull/1
	 * @default false
	 */
	let setOpacityFromMotion: boolean;
}
/**
 * Global configs.
 */
export declare namespace config {
	const LOG_LEVEL_VERBOSE = 0;
	const LOG_LEVEL_WARNING = 1;
	const LOG_LEVEL_ERROR = 2;
	const LOG_LEVEL_NONE = 999;
	/**
	 * Global log level.
	 * @default {@link LOG_LEVEL_WARNING}
	 */
	let logLevel: number;
	/**
	 * Enabling sound for motions.
	 */
	let sound: boolean;
	/**
	 * Deferring motion and corresponding sound until both are loaded.
	 */
	let motionSync: boolean;
	/**
	 * Default fading duration for motions without such value specified.
	 */
	let motionFadingDuration: number;
	/**
	 * Default fading duration for idle motions without such value specified.
	 */
	let idleMotionFadingDuration: number;
	/**
	 * Default fading duration for expressions without such value specified.
	 */
	let expressionFadingDuration: number;
	/**
	 * If false, expression will be reset to default when playing non-idle motions.
	 */
	let preserveExpressionOnMotion: boolean;
	let cubism4: typeof CubismConfig;
}
/**
 * Consistent with the `version` in package.json.
 */
export declare const VERSION: string;
export type Live2DLoaderTarget = Live2DModel | InternalModel | MotionManager | ExpressionManager;
/**
 * The context transferred through Live2DLoader middlewares.
 */
export interface Live2DLoaderContext {
	/** The XHR's response type. */
	type: XMLHttpRequestResponseType;
	/** Will be resolved by {@link ModelSettings.resolveURL} if a ModelSettings is provided. */
	url: string;
	/** If provided, the given URL will be resolved by {@link ModelSettings.resolveURL}. */
	settings?: ModelSettings;
	/**
	 * Owner of this resource. The load task will be automatically canceled
	 * when receiving an "destroy" event from the target.
	 */
	target?: Live2DLoaderTarget;
	/** Loaded data. */
	result?: any;
}
export declare class Live2DLoader {
	static middlewares: Middleware<Live2DLoaderContext>[];
	/**
	 * Loads a resource.
	 * @return Promise that resolves with the loaded data in a format that's consistent with the specified `type`.
	 */
	static load<T = any>(context: Live2DLoaderContext): Promise<T>;
}
/**
 * The basic XHR loader.
 *
 * A network error will be thrown with the following properties:
 * - `url` - The request URL.
 * - `status` - The HTTP status.
 * - `aborted` - True if the error is caused by aborting the XHR.
 */
export declare class XHRLoader {
	/**
	 * All the created XHRs, keyed by their owners respectively.
	 */
	static xhrMap: WeakMap<Live2DLoaderTarget, Set<XMLHttpRequest>>;
	/**
	 * All the created XHRs as a flat array.
	 */
	static allXhrSet: Set<XMLHttpRequest>;
	/**
	 * Middleware for Live2DLoader.
	 */
	static loader: Middleware<Live2DLoaderContext>;
	/**
	 * Creates a managed XHR.
	 * @param target - If provided, the XHR will be canceled when receiving an "destroy" event from the target.
	 * @param url - The URL.
	 * @param type - The XHR response type.
	 * @param onload - Load listener.
	 * @param onerror - Error handler.
	 */
	static createXHR<T = any>(target: Live2DLoaderTarget | undefined, url: string, type: XMLHttpRequestResponseType, onload: (data: T) => void, onerror: (e: Error) => void): XMLHttpRequest;
	/**
	 * Cancels all XHRs related to this target.
	 */
	static cancelXHRs(this: Live2DLoaderTarget): void;
	/**
	 * Release all XHRs.
	 */
	static release(): void;
}
export type ExtendedFileList = File[] & {
	settings?: ModelSettings;
};
/**
 * Experimental loader to load resources from uploaded files.
 *
 * This loader relies on
 * [webkitRelativePath](https://developer.mozilla.org/en-US/docs/Web/API/File/webkitRelativePath)
 * to recognize the file path.
 *
 * Though named as a "Loader", this class has nothing to do with Live2DLoader,
 * it only contains a middleware for the Live2DFactory.
 */
export declare class FileLoader {
	/**
	 * Stores all the object URLs of uploaded files.
	 */
	static filesMap: {
		[settingsFileURL: string]: {
			[resourceFileURL: string]: string;
		};
	};
	/**
	 * Resolves the path of a resource file to the object URL.
	 * @param settingsURL - Object URL of the settings file.
	 * @param filePath - Resource file path.
	 * @return Resolved object URL.
	 */
	static resolveURL(settingsURL: string, filePath: string): string;
	/**
	 * Middleware for Live2DFactory.
	 */
	static factory: Middleware<Live2DFactoryContext>;
	/**
	 * Consumes the files by storing their object URLs. Files not defined in the settings will be ignored.
	 */
	static upload(files: File[], settings: ModelSettings): Promise<void>;
	/**
	 * Creates a ModelSettings by given files.
	 * @return Promise that resolves with the created ModelSettings.
	 */
	static createSettings(files: File[]): Promise<ModelSettings>;
	/**
	 * Reads a file as text in UTF-8.
	 */
	static readText(file: File): Promise<string>;
}
export type ZipReader = any;
/**
 * Experimental loader to load resources from a zip file.
 *
 * Though named as a "Loader", this class has nothing to do with Live2DLoader,
 * it only contains a middleware for the Live2DFactory.
 */
export declare class ZipLoader {
	static ZIP_PROTOCOL: string;
	static uid: number;
	static factory: Middleware<Live2DFactoryContext>;
	static unzip(reader: ZipReader, settings: ModelSettings): Promise<File[]>;
	static createSettings(reader: ZipReader): Promise<ModelSettings>;
	static zipReader(data: Blob, url: string): Promise<ZipReader>;
	static getFilePaths(reader: ZipReader): Promise<string[]>;
	static getFiles(reader: ZipReader, paths: string[]): Promise<File[]>;
	static readText(reader: ZipReader, path: string): Promise<string>;
	static releaseReader(reader: ZipReader): void;
}
/**
 * A simple tagged logger.
 *
 * You can replace the methods with your own ones.
 *
 * ```js
 * import { logger } from 'pixi-live2d-display';
 *
 * logger.log = (tag, ...messages) => {
 *     console.log(tag, 'says:', ...messages);
 * };
 * ```
 */
export declare const logger: {
	log(tag: string, ...messages: any[]): void;
	warn(tag: string, ...messages: any[]): void;
	error(tag: string, ...messages: any[]): void;
};
/**
 * These functions can be slightly faster than the ones in Lodash.
 * @packageDocumentation
 */
export declare function clamp(num: number, lower: number, upper: number): number;
export declare function rand(min: number, max: number): number;
/**
 * Copies a property at only if it matches the `type`.
 * @param type - Type expected to match `typeof` on the property.
 * @param from - Source object.
 * @param to - Destination object.
 * @param fromKey - Key of the property in source object.
 * @param toKey - Key of the property in destination object.
 */
export declare function copyProperty<From, FromKey extends keyof From, ToKey extends keyof any, To extends Partial<Record<ToKey, From[FromKey]>>>(type: string, from: From, to: To, fromKey: FromKey, toKey: ToKey): void;
/**
 * Copies an array at `key`, filtering the items that match the `type`.
 * @param type - Type expected to match `typeof` on the items.
 * @param from - Source object.
 * @param to - Destination object.
 * @param fromKey - Key of the array property in source object.
 * @param toKey - Key of the array property in destination object.
 */
export declare function copyArray<FromKey extends keyof any, From extends Partial<Record<FromKey, any[]>>, ToKey extends keyof any, To extends Partial<Record<ToKey, any[]>>>(type: string, from: From, to: To, fromKey: FromKey, toKey: ToKey): void;
/**
 * @see {@link https://www.typescriptlang.org/docs/handbook/mixins.html}
 */
export declare function applyMixins(derivedCtor: any, baseCtors: any[]): void;
/**
 * Gets the name of parent folder in a url.
 * @param url - URL of a file.
 * @return Name of the parent folder, or the file itself if it has no parent folder.
 */
export declare function folderName(url: string): string;
/**
 * Remove an element from array.
 */
export declare function remove<T>(array: T[], item: T): void;
declare interface Live2DMotion {
	onFinishHandler?(motion: this): void;
}
export namespace Cubism2Spec {
	interface ModelJSON {
		name?: string;
		// files
		model: string;
		pose?: string;
		physics?: string;
		textures: string[];
		// metadata
		layout?: Layout;
		hit_areas?: HitArea[];
		init_params?: InitParam[];
		init_opacities?: InitOpacity[];
		// motions
		expressions?: Expression[];
		motions?: Record<string, Motion[]>;
	}
	interface Layout {
		width?: number;
		height?: number;
		x?: number;
		y?: number;
		center_x?: number;
		center_y?: number;
		top?: number;
		bottom?: number;
		left?: number;
		right?: number;
	}
	interface Motion {
		/** `*.mtn` file. */
		file: string;
		/** Sound file. */
		sound?: string;
		/** Motion fade-in timeout. */
		fade_in?: number;
		/** Motion fade-out timeout. */
		fade_out?: number;
	}
	interface Expression {
		name: string;
		/** `*.json` file. */
		file: string;
	}
	interface HitArea {
		name: string;
		id: string;
	}
	interface InitParam {
		id: string;
		value: number;
	}
	interface InitOpacity {
		id: string;
		value: number;
	}
	interface ExpressionJSON {
		fade_in?: number;
		fade_out?: number;
		params?: {
			id: string;
			val: number;
			def?: number;
			calc?: "set" | "add" | "mult";
		}[];
	}
	interface PhysicsJSON {
		physics_hair?: {
			"comment": string;
			"setup": {
				"length": number;
				"regist": number;
				"mass": number;
			};
			"src": {
				"id": string;
				"ptype": "x" | "y" | "angle";
				"scale": number;
				"weight": number;
			}[];
			"targets": {
				"id": string;
				"ptype": "x" | "y" | "angle";
				"scale": number;
				"weight": number;
			}[];
		}[];
	}
	interface PoseJSON {
		"parts_visible": {
			group: {
				id: string;
				link?: string[];
			}[];
		}[];
	}
}
export declare class Cubism2ModelSettings extends ModelSettings {
	json: Cubism2Spec.ModelJSON;
	moc: string;
	textures: string[];
	pose?: string;
	physics?: string;
	layout?: Cubism2Spec.Layout;
	hitAreas?: Cubism2Spec.HitArea[];
	initParams?: Cubism2Spec.InitParam[];
	initOpacities?: Cubism2Spec.InitOpacity[];
	expressions?: Cubism2Spec.Expression[];
	motions: Record<string, Cubism2Spec.Motion[]>;
	/**
	 * Checks if a JSON object is valid model settings.
	 * @param json
	 */
	static isValidJSON(json: any): json is Cubism2Spec.ModelJSON;
	constructor(json: Cubism2Spec.ModelJSON & {
		url: string;
	});
	/**
	 * Validates and copies *optional* properties from raw JSON.
	 */
	protected copy(json: Cubism2Spec.ModelJSON): void;
	replaceFiles(replace: (file: string, path: string) => string): void;
}
export declare class Live2DExpression extends AMotion {
	readonly params: NonNullable<Cubism2Spec.ExpressionJSON["params"]>;
	constructor(json: Cubism2Spec.ExpressionJSON);
	/** @override */
	updateParamExe(model: Live2DModelWebGL, time: number, weight: number, motionQueueEnt: unknown): void;
}
export declare class Cubism2ExpressionManager extends ExpressionManager<Live2DExpression> {
	readonly queueManager: MotionQueueManager;
	readonly definitions: Cubism2Spec.Expression[];
	readonly settings: Cubism2ModelSettings;
	constructor(settings: Cubism2ModelSettings, options?: MotionManagerOptions);
	isFinished(): boolean;
	getExpressionIndex(name: string): number;
	getExpressionFile(definition: Cubism2Spec.Expression): string;
	createExpression(data: object, definition: Cubism2Spec.Expression | undefined): Live2DExpression;
	protected _setExpression(motion: Live2DExpression): number;
	protected stopAllExpressions(): void;
	protected updateParameters(model: Live2DModelWebGL, dt: number): boolean;
}
export declare class Cubism2MotionManager extends MotionManager<Live2DMotion, Cubism2Spec.Motion> {
	readonly definitions: Partial<Record<string, Cubism2Spec.Motion[]>>;
	readonly groups: {
		readonly idle: "idle";
	};
	readonly motionDataType = "arraybuffer";
	readonly queueManager: MotionQueueManager;
	readonly settings: Cubism2ModelSettings;
	expressionManager?: Cubism2ExpressionManager;
	constructor(settings: Cubism2ModelSettings, options?: MotionManagerOptions);
	protected init(options?: MotionManagerOptions): void;
	isFinished(): boolean;
	createMotion(data: ArrayBuffer, group: string, definition: Cubism2Spec.Motion): Live2DMotion;
	getMotionFile(definition: Cubism2Spec.Motion): string;
	protected getMotionName(definition: Cubism2Spec.Motion): string;
	protected getSoundFile(definition: Cubism2Spec.Motion): string | undefined;
	protected _startMotion(motion: Live2DMotion, onFinish?: (motion: Live2DMotion) => void): number;
	protected _stopAllMotions(): void;
	protected updateParameters(model: Live2DModelWebGL, now: DOMHighResTimeStamp): boolean;
	destroy(): void;
}
export declare const enum EyeState {
	Idle = 0,
	Closing = 1,
	Closed = 2,
	Opening = 3
}
export declare class Live2DEyeBlink {
	readonly coreModel: Live2DModelWebGL;
	leftParam: number;
	rightParam: number;
	blinkInterval: DOMHighResTimeStamp;
	closingDuration: DOMHighResTimeStamp;
	closedDuration: DOMHighResTimeStamp;
	openingDuration: DOMHighResTimeStamp;
	eyeState: EyeState;
	eyeParamValue: number;
	closedTimer: number;
	nextBlinkTimeLeft: number;
	constructor(coreModel: Live2DModelWebGL);
	setEyeParams(value: number): void;
	update(dt: DOMHighResTimeStamp): void;
}
export declare class Live2DPhysics {
	readonly coreModel: Live2DModelWebGL;
	physicsHairs: PhysicsHair[];
	constructor(coreModel: Live2DModelWebGL, json: Cubism2Spec.PhysicsJSON);
	update(elapsed: DOMHighResTimeStamp): void;
}
declare class Live2DPartsParam {
	readonly id: string;
	paramIndex: number;
	partsIndex: number;
	link: Live2DPartsParam[];
	constructor(id: string);
	initIndex(model: Live2DModelWebGL): void;
}
export declare class Live2DPose {
	readonly coreModel: Live2DModelWebGL;
	opacityAnimDuration: DOMHighResTimeStamp;
	partsGroups: Live2DPartsParam[][];
	constructor(coreModel: Live2DModelWebGL, json: Cubism2Spec.PoseJSON);
	init(): void;
	normalizePartsOpacityGroup(partsGroup: Live2DPartsParam[], dt: DOMHighResTimeStamp): void;
	copyOpacity(partsGroup: Live2DPartsParam[]): void;
	update(dt: DOMHighResTimeStamp): void;
}
export declare class Cubism2InternalModel extends InternalModel {
	settings: Cubism2ModelSettings;
	coreModel: Live2DModelWebGL;
	motionManager: Cubism2MotionManager;
	eyeBlink?: Live2DEyeBlink;
	physics?: Live2DPhysics;
	pose?: Live2DPose;
	eyeballXParamIndex: number;
	eyeballYParamIndex: number;
	angleXParamIndex: number;
	angleYParamIndex: number;
	angleZParamIndex: number;
	bodyAngleXParamIndex: number;
	breathParamIndex: number;
	textureFlipY: boolean;
	/**
	 * Number of the drawables in this model.
	 */
	drawDataCount: number;
	/**
	 * If true, the face culling will always be disabled when drawing the model,
	 * regardless of the model's internal flags.
	 */
	disableCulling: boolean;
	constructor(coreModel: Live2DModelWebGL, settings: Cubism2ModelSettings, options?: InternalModelOptions);
	protected init(): void;
	protected getSize(): [
		number,
		number
	];
	protected getLayout(): CommonLayout;
	updateWebGLContext(gl: WebGLRenderingContext, glContextID: number): void;
	bindTexture(index: number, texture: WebGLTexture): void;
	protected getHitAreaDefs(): CommonHitArea[];
	getDrawableIDs(): string[];
	getDrawableIndex(id: string): number;
	getDrawableVertices(drawIndex: number | string): Float32Array;
	update(dt: DOMHighResTimeStamp, now: DOMHighResTimeStamp): void;
	updateFocus(): void;
	updateNaturalMovements(dt: DOMHighResTimeStamp, now: DOMHighResTimeStamp): void;
	draw(gl: WebGLRenderingContext): void;
	destroy(): void;
}
export namespace CubismSpec {
	export interface ModelJSON {
		/**
		 * Json file format version.
		 */
		Version: number;
		/**
		 * Relative paths from the model3.json to other files.
		 */
		FileReferences: {
			/**
			 * Relative path to the moc3 file.
			 */
			Moc: string;
			/**
			 * Relative paths to the textures.
			 */
			Textures: string[];
			/**
			 * [Optional] Relative path to the physics3.json file.
			 */
			Physics?: string;
			/**
			 * [Optional] Relative path to the userdata3.json file.
			 */
			UserData?: string;
			/**
			 * [Optional] Relative path to the pose3.json file.
			 */
			Pose?: string;
			/**
			 * [Optional] Relative path to the cdi3.json file.
			 */
			DisplayInfo?: string;
			/**
			 * [Optional] Relative path to the exp3.json file.
			 */
			Expressions?: Expression[];
			/**
			 * [Optional] Relative path to the motion3.json file.
			 */
			Motions?: {
				/**
				 * This interface was referenced by `undefined`'s JSON-Schema definition
				 * via the `patternProperty` ".+".
				 */
				[k: string]: Motion[];
			};
		};
		/**
		 * [Optional] groups.
		 */
		Groups?: Group[];
		/**
		 * [Optional]Collision detection
		 */
		HitAreas?: HitArea[];
		/**
		 * [Optional]Layout
		 */
		Layout?: {
			Width?: number;
			Height?: number;
			X?: number;
			Y?: number;
			CenterX?: number;
			CenterY?: number;
		};
	}
	/**
	 * Motion.
	 */
	export interface Motion {
		/**
		 * File name.
		 */
		File: string;
		/**
		 * [Optional] Time of the Fade-out for motion easing in seconds.
		 */
		FadeOutTime?: number;
		/**
		 * [Optional] Time of the Fade-In for motion easing in seconds..
		 */
		FadeInTime?: number;
		/**
		 * [Optional] Audio files playback with motion.
		 */
		Sound?: string;
	}
	/**
	 * Group entry.
	 */
	export interface Group {
		/**
		 * Target of group.
		 */
		Target: {
			[k: string]: unknown;
		};
		/**
		 * Unique name of group.
		 */
		Name: string;
		/**
		 * IDs for mapping to target.
		 */
		Ids: string[];
	}
	/**
	 * Collision detection.
	 */
	export interface HitArea {
		/**
		 * Unique name of group.
		 */
		Name: string;
		/**
		 * IDs for mapping to target.
		 */
		Id: string;
	}
	export interface Expression {
		Name: string;
		File: string;
	}
	export interface MotionJSON {
		/**
		 * Json file format version.
		 */
		Version: number;
		/**
		 * Additional data describing the motion.
		 */
		Meta: {
			/**
			 * Duration of the motion in seconds.
			 */
			Duration: number;
			/**
			 * Framerate of the motion in seconds.
			 */
			Fps: number;
			/**
			 * [Optional] Status of the looping of the motion.
			 */
			Loop?: boolean;
			/**
			 * [Optional] Status of the restriction of Bezier handles'X translations.
			 */
			AreBeziersRestricted?: boolean;
			/**
			 * [Optional] Time of the overall Fade-In for easing in seconds.
			 */
			FadeInTime?: number;
			/**
			 * [Optional] Time of the overall Fade-Out for easing in seconds.
			 */
			FadeOutTime?: number;
			/**
			 * The total number of curves.
			 */
			CurveCount: number;
			/**
			 * The total number of segments (from all curves).
			 */
			TotalSegmentCount: number;
			/**
			 * The total number of points (from all segments of all curves).
			 */
			TotalPointCount: number;
			/**
			 * [Optional] The total number of UserData.
			 */
			UserDataCount?: number;
			/**
			 * [Optional] The total size of UserData in bytes.
			 */
			TotalUserDataSize?: number;
		};
		/**
		 * Motion curves.
		 */
		Curves: Curve[];
		/**
		 * [Optional] User data.
		 */
		UserData?: {
			/**
			 * Time in seconds.
			 */
			Time: number;
			/**
			 * Content of user data.
			 */
			Value: string;
		}[];
	}
	/**
	 * Single curve.
	 */
	export interface Curve {
		/**
		 * Target type.
		 */
		Target: string;
		/**
		 * Identifier for mapping curve to target.
		 */
		Id: string;
		/**
		 * [Optional] Time of the Fade-In for easing in seconds.
		 */
		FadeInTime?: number;
		/**
		 * [Optional] Time of the Fade-Out for easing in seconds.
		 */
		FadeOutTime?: number;
		/**
		 * Flattened segments.
		 */
		Segments: number[];
	}
	export interface ExpressionJSON {
		/**
		 * Json file format type.
		 */
		Type: "Live2D Expression";
		/**
		 * [Optional] Time of the Fade-In for easing in seconds.
		 */
		FadeInTime?: number;
		/**
		 * [Optional] Time of the Fade-Out for easing in seconds.
		 */
		FadeOutTime?: number;
		Parameters: {
			Id: string;
			Value: number;
			Blend?: "Add" | "Multiply" | "Overwrite";
		}[];
	}
	export interface PhysicsJSON {
		/**
		 * Physics Settings.
		 */
		PhysicsSettings: {
			/**
			 * Identifier for Physics settings(each model is different).
			 */
			Id: string;
			/**
			 * Input.
			 */
			Input: {
				/**
				 * Targeted parameter.
				 */
				Source: {
					/**
					 * Target type.
					 */
					Target: string;
					/**
					 * Parameter ID.
					 */
					Id: string;
				};
				/**
				 * Effectiveness:propotion of each type0100%.
				 */
				Weight: number;
				/**
				 * Type X or Angle.
				 */
				Type: string;
				/**
				 * Reflect.
				 */
				Reflect: boolean;
			}[];
			/**
			 * Output.
			 */
			Output: {
				/**
				 * Targeted parameter.
				 */
				Destination: {
					/**
					 * Target type.
					 */
					Target: string;
					/**
					 * Parameter ID.
					 */
					Id: string;
				};
				/**
				 * Number0 origin of parent pendulumVertex.
				 */
				VertexIndex: number;
				/**
				 * Scale
				 */
				Scale: number;
				/**
				 * Effectiveness:propotion of each type0100%.
				 */
				Weight: number;
				/**
				 * Type X or Angle (Angle might be fixed)
				 */
				Type: string;
				/**
				 * Reflect
				 */
				Reflect: boolean;
			}[];
			/**
			 * Array of the pendulums
			 */
			Vertices: Vertex[];
			/**
			 * Parameter(input value normalized).
			 */
			Normalization: {
				/**
				 * Normalization value of position.
				 */
				Position: {
					/**
					 * Normalized minimum.
					 */
					Minimum: number;
					/**
					 * Center of the range of normalization.
					 */
					Default: number;
					/**
					 * Normalized maximum.
					 */
					Maximum: number;
				};
				/**
				 * Normalization value of angle.
				 */
				Angle: {
					/**
					 * Normalized minimum.
					 */
					Minimum: number;
					/**
					 * Center of the range of normalization.
					 */
					Default: number;
					/**
					 * Normalized maximum.
					 */
					Maximum: number;
				};
			};
		}[];
		/**
		 * Json file format version.
		 */
		Version: number;
		/**
		 * Additional data describing the physics.
		 */
		Meta: {
			/**
			 * Number of physics settings.
			 */
			PhysicsSettingCount: number;
			/**
			 * Total number of input parameters.
			 */
			TotalInputCount: number;
			/**
			 * Total number of output parameters.
			 */
			TotalOutputCount: number;
			/**
			 * Total number of vertices.
			 */
			VertexCount: number;
			/**
			 * Settings of gravity and wind.
			 */
			EffectiveForces: {
				/**
				 * Gravity.
				 */
				Gravity: {
					X: number;
					Y: number;
				};
				/**
				 * Wind.
				 */
				Wind: {
					X: number;
					Y: number;
				};
			};
			/**
			 * List of names and identifiers of Physics setting.
			 */
			PhysicsDictionary: {
				/**
				 * Identifier for Physics settings(each model is different).
				 */
				Id: string;
				/**
				 * Name of Physics settings(group name).
				 */
				Name: string;
			}[];
		};
	}
	/**
	 * Single vertex.
	 */
	export interface Vertex {
		/**
		 * Default position.
		 */
		Position: {
			X: number;
			Y: number;
		};
		/**
		 * Shaking influence.
		 */
		Mobility: number;
		/**
		 * Reaction time.
		 */
		Delay: number;
		/**
		 * Overall acceleration.
		 */
		Acceleration: number;
		/**
		 * Radius of pendulum.
		 */
		Radius: number;
	}
	export interface PoseJSON {
		Type: "Live2D Pose";
		/**
		 * Time of the Fade-In for easing in seconds.
		 */
		FadeInTime?: number;
		/**
		 * List of the switching control groups.
		 */
		Groups: {
			/**
			 * Main switching Part ID.
			 */
			Id: string;
			/**
			 * List of the linked switching Part IDs.
			 */
			Link?: string[];
		}[][];
	}
	export interface UserDataJSON {
		/**
		 * Json file format version.
		 */
		Version: number;
		/**
		 * Additional data describing the user data.
		 */
		Meta: {
			/**
			 * The total number of UserData.
			 */
			UserDataCount: number;
			/**
			 * The total size of UserData in bytes.
			 */
			TotalUserDataSize: number;
		};
		/**
		 * User data.
		 */
		UserData: UserData[];
	}
	/**
	 * User data.
	 */
	export interface UserData {
		/**
		 * Target type.
		 */
		Target: string;
		/**
		 * Identifier for mapping to target.
		 */
		Id: string;
		/**
		 * Content of user data.
		 */
		Value: string;
	}
}
declare class CubismModelSettingsJson {
	constructor(json: CubismSpec.ModelJSON);
	getEyeBlinkParameters(): string[] | undefined;
	getLipSyncParameters(): string[] | undefined;
	groups?: CubismSpec.Group[];
	moc: string;
	expressions?: CubismSpec.Expression[];
	motions?: Record<string, CubismSpec.Motion[]>;
	textures: string[];
	physics?: string;
	pose?: string;
	hitAreas?: CubismSpec.HitArea[];
	layout?: CubismSpec.ModelJSON["Layout"];
}
export interface Cubism4ModelSettings extends CubismModelSettingsJson {
}
export declare class Cubism4ModelSettings extends ModelSettings {
	json: CubismSpec.ModelJSON;
	moc: string;
	textures: string[];
	static isValidJSON(json: any): json is CubismSpec.ModelJSON;
	constructor(json: CubismSpec.ModelJSON & {
		url: string;
	});
	replaceFiles(replace: (file: string, path: string) => string): void;
}
declare class CubismMatrix44 {
	/**
	 * 
	 */
	constructor();
	/**
	 * 
	 *
	 * @param a a
	 * @param b b
	 * @return 
	 */
	static multiply(a: Float32Array, b: Float32Array, dst: Float32Array): void;
	/**
	 * 
	 */
	loadIdentity(): void;
	/**
	 * 
	 *
	 * @param tr 164x4
	 */
	setMatrix(tr: Float32Array): void;
	/**
	 * 
	 *
	 * @return 164x4
	 */
	getArray(): Float32Array;
	/**
	 * X
	 * @return X
	 */
	getScaleX(): number;
	/**
	 * Y
	 *
	 * @return Y
	 */
	getScaleY(): number;
	/**
	 * X
	 * @return X
	 */
	getTranslateX(): number;
	/**
	 * Y
	 * @return Y
	 */
	getTranslateY(): number;
	/**
	 * X
	 *
	 * @param src X
	 * @return X
	 */
	transformX(src: number): number;
	/**
	 * Y
	 *
	 * @param src Y
	 * @return Y
	 */
	transformY(src: number): number;
	/**
	 * X
	 */
	invertTransformX(src: number): number;
	/**
	 * Y
	 */
	invertTransformY(src: number): number;
	/**
	 * 
	 *
	 * 
	 *
	 * @param x X
	 * @param y Y
	 */
	translateRelative(x: number, y: number): void;
	/**
	 * 
	 *
	 * 
	 *
	 * @param x X
	 * @param y y
	 */
	translate(x: number, y: number): void;
	/**
	 * X
	 *
	 * @param x X
	 */
	translateX(x: number): void;
	/**
	 * Y
	 *
	 * @param y Y
	 */
	translateY(y: number): void;
	/**
	 * 
	 *
	 * @param x X
	 * @param y Y
	 */
	scaleRelative(x: number, y: number): void;
	/**
	 * 
	 *
	 * @param x X
	 * @param y Y
	 */
	scale(x: number, y: number): void;
	/**
	 * 
	 *
	 * @param m 
	 */
	multiplyByMatrix(m: CubismMatrix44): void;
	/**
	 * 
	 */
	clone(): CubismMatrix44;
	protected _tr: Float32Array;
}
declare abstract class CubismRenderer {
	/**
	 * 
	 * 
	 * @param model 
	 */
	initialize(model: CubismModel): void;
	/**
	 * 
	 */
	drawModel(): void;
	/**
	 * Model-View-Projection 
	 * 
	 * @param matrix44 Model-View-Projection 
	 */
	setMvpMatrix(matrix44: CubismMatrix44): void;
	/**
	 * Model-View-Projection 
	 * @return Model-View-Projection 
	 */
	getMvpMatrix(): CubismMatrix44;
	/**
	 * 
	 * 0.0~1.01.0
	 * @param red 
	 * @param green 
	 * @param blue 
	 * @param alpha 
	 */
	setModelColor(red: number, green: number, blue: number, alpha: number): void;
	/**
	 * 
	 * 0.0~1.0(1.0)
	 *
	 * @return RGBA
	 */
	getModelColor(): CubismTextureColor;
	/**
	 * 
	 * truefalse
	 */
	setIsPremultipliedAlpha(enable: boolean): void;
	/**
	 * 
	 * @return true 
	 * @return false 
	 */
	isPremultipliedAlpha(): boolean;
	/**
	 * 
	 * truefalse
	 */
	setIsCulling(culling: boolean): void;
	/**
	 * 
	 * @return true 
	 * @return false 
	 */
	isCulling(): boolean;
	/**
	 * 
	 * 
	 * @param n 
	 */
	setAnisotropy(n: number): void;
	/**
	 * 
	 * @return 
	 */
	getAnisotropy(): number;
	/**
	 * 
	 * @return 
	 */
	getModel(): CubismModel;
	/**
	 * 
	 */
	protected constructor();
	/**
	 * 
	 */
	abstract doDrawModel(): void;
	/**
	 * 
	 * 
	 * @param textureNo 
	 * @param indexCount 
	 * @param vertexCount 
	 * @param indexArray 
	 * @param vertexArray 
	 * @param uvArray uv
	 * @param opacity 
	 * @param colorBlendMode 
	 * @param invertedMask 
	 */
	abstract drawMesh(textureNo: number, indexCount: number, vertexCount: number, indexArray: Uint16Array, vertexArray: Float32Array, uvArray: Float32Array, opacity: number, colorBlendMode: CubismBlendMode, invertedMask: boolean): void;
	/**
	 * 
	 */
	static staticRelease: Function;
	protected _mvpMatrix4x4: CubismMatrix44;
	protected _modelColor: CubismTextureColor;
	protected _isCulling: boolean;
	protected _isPremultipliedAlpha: boolean;
	protected _anisortopy: any;
	protected _model: CubismModel;
}
declare enum CubismBlendMode {
	CubismBlendMode_Normal = 0,
	CubismBlendMode_Additive = 1,
	CubismBlendMode_Multiplicative = 2
}
declare class CubismTextureColor {
	/**
	 * 
	 */
	constructor();
	R: number;
	G: number;
	B: number;
	A: number;
}
declare class CubismModel {
	/**
	 * 
	 */
	update(): void;
	/**
	 * 
	 */
	getCanvasWidth(): number;
	/**
	 * 
	 */
	getCanvasHeight(): number;
	/**
	 * 
	 */
	saveParameters(): void;
	/**
	 * 
	 */
	getModel(): Live2DCubismCore.Model;
	/**
	 * 
	 * @param partId ID
	 * @return 
	 */
	getPartIndex(partId: string): number;
	/**
	 * 
	 * @return 
	 */
	getPartCount(): number;
	/**
	 * (Index)
	 * @param partIndex 
	 * @param opacity 
	 */
	setPartOpacityByIndex(partIndex: number, opacity: number): void;
	/**
	 * (Id)
	 * @param partId ID
	 * @param opacity 
	 */
	setPartOpacityById(partId: string, opacity: number): void;
	/**
	 * (index)
	 * @param partIndex 
	 * @return 
	 */
	getPartOpacityByIndex(partIndex: number): number;
	/**
	 * (id)
	 * @param partId 
	 * @return 
	 */
	getPartOpacityById(partId: string): number;
	/**
	 * 
	 * @param ID
	 * @return 
	 */
	getParameterIndex(parameterId: string): number;
	/**
	 * 
	 * @return 
	 */
	getParameterCount(): number;
	/**
	 * 
	 * @param parameterIndex 
	 * @return 
	 */
	getParameterMaximumValue(parameterIndex: number): number;
	/**
	 * 
	 * @param parameterIndex 
	 * @return 
	 */
	getParameterMinimumValue(parameterIndex: number): number;
	/**
	 * 
	 * @param parameterIndex 
	 * @return 
	 */
	getParameterDefaultValue(parameterIndex: number): number;
	/**
	 * 
	 * @param parameterIndex    
	 * @return 
	 */
	getParameterValueByIndex(parameterIndex: number): number;
	/**
	 * 
	 * @param parameterId    ID
	 * @return 
	 */
	getParameterValueById(parameterId: string): number;
	/**
	 * 
	 * @param parameterIndex 
	 * @param value 
	 * @param weight 
	 */
	setParameterValueByIndex(parameterIndex: number, value: number, weight?: number): void;
	/**
	 * 
	 * @param parameterId ID
	 * @param value 
	 * @param weight 
	 */
	setParameterValueById(parameterId: string, value: number, weight?: number): void;
	/**
	 * (index)
	 * @param parameterIndex 
	 * @param value 
	 * @param weight 
	 */
	addParameterValueByIndex(parameterIndex: number, value: number, weight?: number): void;
	/**
	 * (id)
	 * @param parameterId 
	 * @param value 
	 * @param weight 
	 */
	addParameterValueById(parameterId: any, value: number, weight?: number): void;
	/**
	 * 
	 * @param parameterId ID
	 * @param value 
	 * @param weight 
	 */
	multiplyParameterValueById(parameterId: string, value: number, weight?: number): void;
	/**
	 * 
	 * @param parameterIndex 
	 * @param value 
	 * @param weight 
	 */
	multiplyParameterValueByIndex(parameterIndex: number, value: number, weight?: number): void;
	getDrawableIds(): string[];
	/**
	 * Drawable
	 * @param drawableId DrawableID
	 * @return Drawable
	 */
	getDrawableIndex(drawableId: string): number;
	/**
	 * Drawable
	 * @return drawable
	 */
	getDrawableCount(): number;
	/**
	 * DrawableID
	 * @param drawableIndex Drawable
	 * @return drawableID
	 */
	getDrawableId(drawableIndex: number): string;
	/**
	 * Drawable
	 * @return Drawable
	 */
	getDrawableRenderOrders(): Int32Array;
	/**
	 * Drawable
	 * @param drawableIndex Drawable
	 * @return drawable
	 */
	getDrawableTextureIndices(drawableIndex: number): number;
	/**
	 * DrawableVertexPositions
	 *
	 * CubismModel.updateDrawable
	 *
	 * @param   drawableIndex   Drawable
	 * @retval  true    DrawableCubismModel.update
	 * @retval  false   DrawableCubismModel.update
	 */
	getDrawableDynamicFlagVertexPositionsDidChange(drawableIndex: number): boolean;
	/**
	 * Drawable
	 * @param drawableIndex Drawable
	 * @return drawable
	 */
	getDrawableVertexIndexCount(drawableIndex: number): number;
	/**
	 * Drawable
	 * @param drawableIndex Drawable
	 * @return drawable
	 */
	getDrawableVertexCount(drawableIndex: number): number;
	/**
	 * Drawable
	 * @param drawableIndex drawable
	 * @return drawable
	 */
	getDrawableVertices(drawableIndex: number): Float32Array;
	/**
	 * Drawable
	 * @param drarableIndex Drawable
	 * @return drawable
	 */
	getDrawableVertexIndices(drawableIndex: number): Uint16Array;
	/**
	 * Drawable
	 * @param drawableIndex Drawable
	 * @return drawable
	 */
	getDrawableVertexPositions(drawableIndex: number): Float32Array;
	/**
	 * DrawableUV
	 * @param drawableIndex Drawable
	 * @return drawableUV
	 */
	getDrawableVertexUvs(drawableIndex: number): Float32Array;
	/**
	 * Drawable
	 * @param drawableIndex Drawable
	 * @return drawable
	 */
	getDrawableOpacity(drawableIndex: number): number;
	/**
	 * Drawable
	 * @param drawableIndex Drawable
	 * @return drawable
	 */
	getDrawableCulling(drawableIndex: number): boolean;
	/**
	 * Drawable
	 * @param drawableIndex Drawable
	 * @return drawable
	 */
	getDrawableBlendMode(drawableIndex: number): CubismBlendMode;
	/**
	 * Drawable
	 *
	 * Drawable
	 * 
	 *
	 * @param drawableIndex Drawable
	 * @return Drawable
	 */
	getDrawableInvertedMaskBit(drawableIndex: number): boolean;
	/**
	 * Drawable
	 * @return Drawable
	 */
	getDrawableMasks(): Int32Array[];
	/**
	 * Drawable
	 * @return Drawable
	 */
	getDrawableMaskCounts(): Int32Array;
	/**
	 * 
	 *
	 * @return true 
	 * @return false 
	 */
	isUsingMasking(): boolean;
	/**
	 * Drawable
	 *
	 * @param drawableIndex Drawable
	 * @return true Drawable
	 * @return false Drawable
	 */
	getDrawableDynamicFlagIsVisible(drawableIndex: number): boolean;
	/**
	 * DrawableDrawOrder
	 *
	 * CubismModel.updatedrawabledrawOrder
	 * drawOrderartMesh01000
	 * @param drawableIndex drawable
	 * @return true drawableCubismModel.update
	 * @return false drawableCubismModel.update
	 */
	getDrawableDynamicFlagVisibilityDidChange(drawableIndex: number): boolean;
	/**
	 * Drawable
	 *
	 * CubismModel.updatedrawable
	 *
	 * @param drawableIndex drawable
	 * @return true DrawableCubismModel.update
	 * @return false DrawableCubismModel.update
	 */
	getDrawableDynamicFlagOpacityDidChange(drawableIndex: number): boolean;
	/**
	 * Drawable
	 *
	 * CubismModel.updateDrawable
	 *
	 * @param drawableIndex Drawable
	 * @return true DrawableCubismModel.update
	 * @return false DrawableCubismModel.update
	 */
	getDrawableDynamicFlagRenderOrderDidChange(drawableIndex: number): boolean;
	/**
	 * 
	 */
	loadParameters(): void;
	/**
	 * 
	 */
	initialize(): void;
	/**
	 * 
	 * @param model 
	 */
	constructor(model: Live2DCubismCore.Model);
	/**
	 * 
	 */
	release(): void;
	private _notExistPartOpacities;
	private _notExistPartId;
	private _notExistParameterValues;
	private _notExistParameterId;
	private _savedParameters;
	private _model;
	private _parameterValues;
	private _parameterMaximumValues;
	private _parameterMinimumValues;
	private _partOpacities;
	private _parameterIds;
	private _partIds;
	private _drawableIds;
}
declare class CubismMotionQueueManager {
	/**
	 * 
	 */
	constructor();
	/**
	 * 
	 */
	release(): void;
	/**
	 * 
	 *
	 * 
	 *
	 * @param   motion          
	 * @param   autoDelete       true
	 * @param   userTimeSeconds []
	 * @return                      IsFinished()-1
	 */
	startMotion(motion: ACubismMotion, autoDelete: boolean, userTimeSeconds: number): CubismMotionQueueEntryHandle;
	/**
	 * 
	 * @return true 
	 * @return false 
	 */
	isFinished(): boolean;
	/**
	 * 
	 * @param motionQueueEntryNumber 
	 * @return true 
	 * @return false 
	 */
	isFinishedByHandle(motionQueueEntryNumber: CubismMotionQueueEntryHandle): boolean;
	/**
	 * 
	 */
	stopAllMotions(): void;
	/**
	 * CubismMotionQueueEntry
  
	 * @param   motionQueueEntryNumber  
	 * @return  CubismMotionQueueEntry
	 * @return  null   
	 */
	getCubismMotionQueueEntry(motionQueueEntryNumber: any): CubismMotionQueueEntry | undefined;
	/**
	 * Callback
	 *
	 * @param callback 
	 * @param customData 
	 */
	setEventCallback(callback: CubismMotionEventFunction, customData?: any): void;
	/**
	 * 
	 *
	 * @param   model   
	 * @param   userTimeSeconds   []
	 * @return  true    
	 * @return  false   ()
	 */
	doUpdateMotion(model: CubismModel, userTimeSeconds: number): boolean;
	_userTimeSeconds: number;
	_motions: CubismMotionQueueEntry[];
	_eventCallBack: CubismMotionEventFunction;
	_eventCustomData: any;
}
/**
 * 
 *
 * 
 * @param caller        CubismMotionQueueManager
 * @param eventValue    
 * @param customData   
 */
export interface CubismMotionEventFunction {
	(caller: CubismMotionQueueManager, eventValue: string, customData: any): void;
}
/**
 * 
 *
 * 
 */
export declare type CubismMotionQueueEntryHandle = any;
declare class CubismMotionQueueEntry {
	/**
	 * 
	 */
	constructor();
	/**
	 * 
	 */
	release(): void;
	/**
	 * 
	 * @param fadeOutSeconds []
	 */
	setFadeOut(fadeOutSeconds: number): void;
	/**
	 * 
	 * @param fadeOutSeconds []
	 * @param userTimeSeconds []
	 */
	startFadeOut(fadeOutSeconds: number, userTimeSeconds: number): void;
	/**
	 * 
	 *
	 * @return true 
	 * @return false 
	 */
	isFinished(): boolean;
	/**
	 * 
	 * @return true 
	 * @return false 
	 */
	isStarted(): boolean;
	/**
	 * 
	 * @return []
	 */
	getStartTime(): number;
	/**
	 * 
	 * @return []
	 */
	getFadeInStartTime(): number;
	/**
	 * 
	 * @return 
	 */
	getEndTime(): number;
	/**
	 * 
	 * @param startTime 
	 */
	setStartTime(startTime: number): void;
	/**
	 * 
	 * @param startTime []
	 */
	setFadeInStartTime(startTime: number): void;
	/**
	 * 
	 * @param endTime []
	 */
	setEndTime(endTime: number): void;
	/**
	 * 
	 * @param f true
	 */
	setIsFinished(f: boolean): void;
	/**
	 * 
	 * @param f true
	 */
	setIsStarted(f: boolean): void;
	/**
	 * 
	 * @return true 
	 * @return false 
	 */
	isAvailable(): boolean;
	/**
	 * 
	 * @param v true
	 */
	setIsAvailable(v: boolean): void;
	/**
	 * 
	 * @param timeSeconds []
	 * @param weight 
	 */
	setState(timeSeconds: number, weight: number): void;
	/**
	 * 
	 * @return []
	 */
	getStateTime(): number;
	/**
	 * 
	 * @return 
	 */
	getStateWeight(): number;
	/**
	 * 
	 *
	 * @return []
	 */
	getLastCheckEventSeconds(): number;
	/**
	 * 
	 * @param checkSeconds []
	 */
	setLastCheckEventSeconds(checkSeconds: number): void;
	/**
	 * 
	 * @return 
	 */
	isTriggeredFadeOut(): boolean;
	/**
	 * 
	 * @return []
	 */
	getFadeOutSeconds(): number;
	_autoDelete: boolean;
	_motion: ACubismMotion;
	_available: boolean;
	_finished: boolean;
	_started: boolean;
	_startTimeSeconds: number;
	_fadeInStartTimeSeconds: number;
	_endTimeSeconds: number;
	_stateTimeSeconds: number;
	_stateWeight: number;
	_lastEventCheckSeconds: number;
	private _fadeOutSeconds;
	private _isTriggeredFadeOut;
	_motionQueueEntryHandle: CubismMotionQueueEntryHandle;
}
declare abstract class ACubismMotion {
	/**
  >>>>>>> 13ba60d (Update to Cubism SDK for Web R4)
	 * 
	 */
	constructor();
	/**
	 * 
	 */
	release(): void;
	/**
	 * 
	 * @param model 
	 * @param motionQueueEntry CubismMotionQueueManager
	 * @param userTimeSeconds []
	 */
	updateParameters(model: CubismModel, motionQueueEntry: CubismMotionQueueEntry, userTimeSeconds: number): void;
	/**
	 * 
	 * @param fadeInSeconds []
	 */
	setFadeInTime(fadeInSeconds: number): void;
	/**
	 * 
	 * @param fadeOutSeconds []
	 */
	setFadeOutTime(fadeOutSeconds: number): void;
	/**
	 * 
	 * @return []
	 */
	getFadeOutTime(): number;
	/**
	 * 
	 * @return []
	 */
	getFadeInTime(): number;
	/**
	 * 
	 * @param weight 0.0 - 1.0
	 */
	setWeight(weight: number): void;
	/**
	 * 
	 * @return 0.0 - 1.0
	 */
	getWeight(): number;
	/**
	 * 
	 * @return []
	 *
	 * @note -1
	 *       
	 *       
	 *       -1
	 */
	getDuration(): number;
	/**
	 * 1
	 * @return []
	 *
	 * @note getDuration()
	 *       ()-1
	 */
	getLoopDuration(): number;
	/**
	 * 
	 * @param offsetSeconds []
	 */
	setOffsetTime(offsetSeconds: number): void;
	/**
	 * 
	 *
	 * 
	 * 
	 *
	 * @param beforeCheckTimeSeconds []
	 * @param motionTimeSeconds []
	 */
	getFiredEvent(beforeCheckTimeSeconds: number, motionTimeSeconds: number): string[];
	/**
	 * 
	 * @param model 
	 * @param userTimeSeconds []
	 * @param weight 
	 * @param motionQueueEntry CubismMotionQueueManager
	 * @return true 
	 * @return false 
	 */
	abstract doUpdateParameters(model: CubismModel, userTimeSeconds: number, weight: number, motionQueueEntry: CubismMotionQueueEntry): void;
	/**
	 * 
	 *
	 * 
	 * isFinished
	 * :
	 *   1. 
	 *   2. 
	 *
	 * @param onFinishedMotionHandler 
	 */
	setFinishedMotionHandler(onFinishedMotionHandler?: (self: ACubismMotion) => void): void;
	/**
	 * 
	 *
	 * 
	 *
	 * @return 
	 */
	getFinishedMotionHandler(): ((self: ACubismMotion) => void) | undefined;
	_fadeInSeconds: number;
	_fadeOutSeconds: number;
	_weight: number;
	_offsetSeconds: number;
	_firedEventValues: string[];
	_onFinishedMotion?: (self: ACubismMotion) => void;
}
declare class CubismExpressionMotion extends ACubismMotion {
	/**
	 * 
	 * @param json exp
	 * @param size 
	 * @return 
	 */
	static create(json: CubismSpec.ExpressionJSON): CubismExpressionMotion;
	/**
	 * 
	 * @param model 
	 * @param userTimeSeconds []
	 * @param weight 
	 * @param motionQueueEntry CubismMotionQueueManager
	 */
	doUpdateParameters(model: CubismModel, userTimeSeconds: number, weight: number, motionQueueEntry: CubismMotionQueueEntry): void;
	/**
	 * 
	 */
	constructor();
	_parameters: ExpressionParameter[];
}
declare enum ExpressionBlendType {
	ExpressionBlendType_Add = 0,
	ExpressionBlendType_Multiply = 1,
	ExpressionBlendType_Overwrite = 2
}
/**
 * 
 */
export interface ExpressionParameter {
	parameterId: string;
	blendType: ExpressionBlendType;
	value: number;
}
export declare class Cubism4ExpressionManager extends ExpressionManager<CubismExpressionMotion, CubismSpec.Expression> {
	readonly queueManager: CubismMotionQueueManager;
	readonly definitions: CubismSpec.Expression[];
	constructor(settings: Cubism4ModelSettings, options?: MotionManagerOptions);
	isFinished(): boolean;
	getExpressionIndex(name: string): number;
	getExpressionFile(definition: CubismSpec.Expression): string;
	createExpression(data: object, definition: CubismSpec.Expression | undefined): CubismExpressionMotion;
	protected _setExpression(motion: CubismExpressionMotion): number;
	protected stopAllExpressions(): void;
	protected updateParameters(model: CubismModel, now: DOMHighResTimeStamp): boolean;
}
declare enum CubismMotionCurveTarget {
	CubismMotionCurveTarget_Model = 0,
	CubismMotionCurveTarget_Parameter = 1,
	CubismMotionCurveTarget_PartOpacity = 2
}
declare class CubismMotionPoint {
	constructor(time?: number, value?: number);
	time: number;
	value: number;
}
/**
 * 
 *
 * @param   points      
 * @param   time        []
 */
export interface csmMotionSegmentEvaluationFunction {
	(points: CubismMotionPoint[], time: number): number;
}
declare class CubismMotionSegment {
	/**
	 * @brief 
	 *
	 * 
	 */
	constructor();
	evaluate: csmMotionSegmentEvaluationFunction;
	basePointIndex: number;
	segmentType: number;
}
declare class CubismMotionCurve {
	constructor();
	type: CubismMotionCurveTarget;
	id: string;
	segmentCount: number;
	baseSegmentIndex: number;
	fadeInTime: number;
	fadeOutTime: number;
}
declare class CubismMotionEvent {
	fireTime: number;
	value: string;
}
declare class CubismMotionData {
	constructor();
	duration: number;
	loop: boolean;
	curveCount: number;
	eventCount: number;
	fps: number;
	curves: CubismMotionCurve[];
	segments: CubismMotionSegment[];
	points: CubismMotionPoint[];
	events: CubismMotionEvent[];
}
declare class CubismMotion extends ACubismMotion {
	/**
	 * 
	 *
	 * @param json motion3.json
	 * @param onFinishedMotionHandler 
	 * @return 
	 */
	static create(json: CubismSpec.MotionJSON, onFinishedMotionHandler?: (self: ACubismMotion) => void): CubismMotion;
	/**
	 * 
	 * @param model             
	 * @param userTimeSeconds   []
	 * @param fadeWeight        
	 * @param motionQueueEntry  CubismMotionQueueManager
	 */
	doUpdateParameters(model: CubismModel, userTimeSeconds: number, fadeWeight: number, motionQueueEntry: CubismMotionQueueEntry): void;
	/**
	 * 
	 * @param loop 
	 */
	setIsLoop(loop: boolean): void;
	/**
	 * 
	 * @return true 
	 * @return false 
	 */
	isLoop(): boolean;
	/**
	 * 
	 * @param loopFadeIn  
	 */
	setIsLoopFadeIn(loopFadeIn: boolean): void;
	/**
	 * 
	 *
	 * @return  true    
	 * @return  false   
	 */
	isLoopFadeIn(): boolean;
	/**
	 * 
	 *
	 * @return  []
	 */
	getDuration(): number;
	/**
	 * 
	 *
	 * @return  []
	 */
	getLoopDuration(): number;
	/**
	 * 
	 *
	 * @param parameterId     ID
	 * @param value           []
	 */
	setParameterFadeInTime(parameterId: string, value: number): void;
	/**
	 * 
	 * @param parameterId     ID
	 * @param value           []
	 */
	setParameterFadeOutTime(parameterId: string, value: number): void;
	/**
	 * 
	 * @param    parameterId     ID
	 * @return   []
	 */
	getParameterFadeInTime(parameterId: string): number;
	/**
	 * 
	 *
	 * @param   parameterId     ID
	 * @return   []
	 */
	getParameterFadeOutTime(parameterId: string): number;
	/**
	 * ID
	 * @param eyeBlinkParameterIds    ID
	 * @param lipSyncParameterIds     ID
	 */
	setEffectIds(eyeBlinkParameterIds: string[], lipSyncParameterIds: string[]): void;
	/**
	 * 
	 */
	constructor();
	/**
	 * 
	 */
	release(): void;
	/**
	 * motion3.json
	 *
	 * @param motionJson  motion3.json
	 */
	parse(motionJson: CubismSpec.MotionJSON): void;
	/**
	 * 
	 *
	 * 
	 * 
	 *
	 * @param beforeCheckTimeSeconds   []
	 * @param motionTimeSeconds        []
	 */
	getFiredEvent(beforeCheckTimeSeconds: number, motionTimeSeconds: number): string[];
	_sourceFrameRate: number;
	_loopDurationSeconds: number;
	_isLoop: boolean;
	_isLoopFadeIn: boolean;
	_lastWeight: number;
	_motionData: CubismMotionData;
	_eyeBlinkParameterIds: string[];
	_lipSyncParameterIds: string[];
	_modelCurveIdEyeBlink?: string;
	_modelCurveIdLipSync?: string;
}
export declare class Cubism4MotionManager extends MotionManager<CubismMotion, CubismSpec.Motion> {
	readonly definitions: Partial<Record<string, CubismSpec.Motion[]>>;
	readonly groups: {
		readonly idle: "Idle";
	};
	readonly motionDataType = "json";
	readonly queueManager: CubismMotionQueueManager;
	readonly settings: Cubism4ModelSettings;
	expressionManager?: Cubism4ExpressionManager;
	eyeBlinkIds: string[];
	lipSyncIds: string[];
	constructor(settings: Cubism4ModelSettings, options?: MotionManagerOptions);
	protected init(options?: MotionManagerOptions): void;
	isFinished(): boolean;
	protected _startMotion(motion: CubismMotion, onFinish?: (motion: CubismMotion) => void): number;
	protected _stopAllMotions(): void;
	createMotion(data: object, group: string, definition: CubismSpec.Motion): CubismMotion;
	getMotionFile(definition: CubismSpec.Motion): string;
	protected getMotionName(definition: CubismSpec.Motion): string;
	protected getSoundFile(definition: CubismSpec.Motion): string | undefined;
	protected updateParameters(model: CubismModel, now: DOMHighResTimeStamp): boolean;
	destroy(): void;
}
declare class CubismBreath {
	/**
	 * 
	 */
	static create(): CubismBreath;
	/**
	 * 
	 * @param breathParameters 
	 */
	setParameters(breathParameters: BreathParameterData[]): void;
	/**
	 * 
	 * @return 
	 */
	getParameters(): BreathParameterData[];
	/**
	 * 
	 * @param model 
	 * @param deltaTimeSeconds []
	 */
	updateParameters(model: CubismModel, deltaTimeSeconds: number): void;
	/**
	 * 
	 */
	constructor();
	_breathParameters: BreathParameterData[];
	_currentTime: number;
}
declare class BreathParameterData {
	/**
	 * 
	 * @param parameterId   ID
	 * @param offset        
	 * @param peak          
	 * @param cycle         
	 * @param weight        
	 */
	constructor(parameterId?: string, offset?: number, peak?: number, cycle?: number, weight?: number);
	parameterId?: string;
	offset: number;
	peak: number;
	cycle: number;
	weight: number;
}
declare class CubismEyeBlink {
	/**
	 * 
	 * @param modelSetting 
	 * @return 
	 * @note NULLID
	 */
	static create(modelSetting: CubismModelSettingsJson): CubismEyeBlink;
	/**
	 * 
	 * @param blinkingInterval []
	 */
	setBlinkingInterval(blinkingInterval: number): void;
	/**
	 * 
	 * @param closing   []
	 * @param closed    []
	 * @param opening   []
	 */
	setBlinkingSetting(closing: number, closed: number, opening: number): void;
	/**
	 * ID
	 * @param parameterIds ID
	 */
	setParameterIds(parameterIds: string[]): void;
	/**
	 * ID
	 * @return ID
	 */
	getParameterIds(): string[];
	/**
	 * 
	 * @param model 
	 * @param deltaTimeSeconds []
	 */
	updateParameters(model: CubismModel, deltaTimeSeconds: number): void;
	/**
	 * 
	 * @param modelSetting 
	 */
	constructor(modelSetting: CubismModelSettingsJson);
	/**
	 * 
	 *
	 * @return []
	 */
	determinNextBlinkingTiming(): number;
	_blinkingState: number;
	_parameterIds: string[];
	_nextBlinkingTime: number;
	_stateStartTimeSeconds: number;
	_blinkingIntervalSeconds: number;
	_closingSeconds: number;
	_closedSeconds: number;
	_openingSeconds: number;
	_userTimeSeconds: number;
	/**
	 * ID0 true 1 false 
	 */
	static readonly CloseIfZero: boolean;
}
declare class CubismPose {
	/**
	 * 
	 * @param pose3json pose3.json
	 * @return 
	 */
	static create(pose3json: CubismSpec.PoseJSON): CubismPose;
	/**
	 * 
	 * @param model 
	 * @param deltaTimeSeconds []
	 */
	updateParameters(model: CubismModel, deltaTimeSeconds: number): void;
	/**
	 * 
	 * @param model 
	 * @note 0
	 */
	reset(model: CubismModel): void;
	/**
	 * 
	 *
	 * @param model 
	 */
	copyPartOpacities(model: CubismModel): void;
	/**
	 * 
	 * @param model 
	 * @param deltaTimeSeconds []
	 * @param beginIndex 
	 * @param partGroupCount 
	 */
	doFade(model: CubismModel, deltaTimeSeconds: number, beginIndex: number, partGroupCount: number): void;
	/**
	 * 
	 */
	constructor();
	_partGroups: PartData[];
	_partGroupCounts: number[];
	_fadeTimeSeconds: number;
	_lastModel?: CubismModel;
}
declare class PartData {
	/**
	 * 
	 */
	constructor(v?: PartData);
	/**
	 * =
	 */
	assignment(v: PartData): PartData;
	/**
	 * 
	 * @param model 
	 */
	initialize(model: CubismModel): void;
	/**
	 * 
	 */
	clone(): PartData;
	partId: string;
	parameterIndex: number;
	partIndex: number;
	link: PartData[];
}
/**
 * 
 *
 * Json
 */
export interface CubismModelUserDataNode {
	targetType: string;
	targetId: string;
	value: string;
}
declare class CubismModelUserData {
	/**
	 * 
	 *
	 * @param json    userdata3.json
	 * @param size      
	 * @return 
	 */
	static create(json: CubismSpec.UserDataJSON, size: number): CubismModelUserData;
	/**
	 * ArtMesh
	 *
	 * @return 
	 */
	getArtMeshUserDatas(): CubismModelUserDataNode[];
	/**
	 * userdata3.json
	 *
	 * @param data    userdata3.json
	 * @param size      
	 */
	parseUserData(data: CubismSpec.UserDataJSON, size: number): void;
	/**
	 * 
	 */
	constructor();
	/**
	 * 
	 *
	 * 
	 */
	release(): void;
	private _userDataNodes;
	private _artMeshUserDataNode;
}
declare class CubismVector2 {
	x: number;
	y: number;
	/**
	 * 
	 */
	constructor(x?: number, y?: number);
	/**
	 * 
	 *
	 * @param vector2 
	 * @return  
	 */
	add(vector2: CubismVector2): CubismVector2;
	/**
	 * 
	 *
	 * @param vector2 
	 * @return  
	 */
	substract(vector2: CubismVector2): CubismVector2;
	/**
	 * 
	 *
	 * @param vector2 
	 * @return  
	 */
	multiply(vector2: CubismVector2): CubismVector2;
	/**
	 * ()
	 *
	 * @param scalar 
	 * @return  
	 */
	multiplyByScaler(scalar: number): CubismVector2;
	/**
	 * 
	 *
	 * @param vector2 
	 * @return  
	 */
	division(vector2: CubismVector2): CubismVector2;
	/**
	 * ()
	 *
	 * @param scalar 
	 * @return  
	 */
	divisionByScalar(scalar: number): CubismVector2;
	/**
	 * 
	 *
	 * @return 
	 */
	getLength(): number;
	/**
	 * 
	 *
	 * @param a 
	 * @return 
	 */
	getDistanceWith(a: CubismVector2): number;
	/**
	 * 
	 *
	 * @param a 
	 * @return 
	 */
	dot(a: CubismVector2): number;
	/**
	 * 
	 */
	normalize(): void;
	/**
	 * 
	 *
	 * 
	 *
	 * @param rhs 
	 * @return true 
	 * @return false 
	 */
	isEqual(rhs: CubismVector2): boolean;
	/**
	 * 
	 *
	 * 
	 *
	 * @param rhs 
	 * @return true 
	 * @return false 
	 */
	isNotEqual(rhs: CubismVector2): boolean;
}
declare enum CubismPhysicsTargetType {
	CubismPhysicsTargetType_Parameter = 0
}
declare enum CubismPhysicsSource {
	CubismPhysicsSource_X = 0,
	CubismPhysicsSource_Y = 1,
	CubismPhysicsSource_Angle = 2
}
/**
 * 
 */
export interface CubismPhysicsParameter {
	id: string;
	targetType: CubismPhysicsTargetType;
}
/**
 * 
 */
export interface CubismPhysicsNormalization {
	minimum: number;
	maximum: number;
	defalut: number;
}
declare class CubismPhysicsParticle {
	constructor();
	initialPosition: CubismVector2;
	mobility: number;
	delay: number;
	acceleration: number;
	radius: number;
	position: CubismVector2;
	lastPosition: CubismVector2;
	lastGravity: CubismVector2;
	force: CubismVector2;
	velocity: CubismVector2;
}
declare class CubismPhysicsSubRig {
	inputCount: number;
	outputCount: number;
	particleCount: number;
	baseInputIndex: number;
	baseOutputIndex: number;
	baseParticleIndex: number;
	normalizationPosition: CubismPhysicsNormalization;
	normalizationAngle: CubismPhysicsNormalization;
}
/**
 * 
 * @param targetTranslation     // 
 * @param targetAngle           // 
 * @param value                 // 
 * @param parameterMinimunValue // 
 * @param parameterMaximumValue // 
 * @param parameterDefaultValue // 
 * @param normalizationPosition // 
 * @param normalizationAngle    // 
 * @param isInverted            // 
 * @param weight                // 
 */
export interface normalizedPhysicsParameterValueGetter {
	(targetTranslation: CubismVector2, targetAngle: {
		angle: number;
	}, value: number, parameterMinimunValue: number, parameterMaximumValue: number, parameterDefaultValue: number, normalizationPosition: CubismPhysicsNormalization, normalizationAngle: CubismPhysicsNormalization, isInverted: boolean, weight: number): void;
}
/**
 * 
 * @param translation 
 * @param particles 
 * @param isInverted 
 * @param parentGravity 
 * @return 
 */
export interface physicsValueGetter {
	(translation: CubismVector2, particles: CubismPhysicsParticle[], particleIndex: number, isInverted: boolean, parentGravity: CubismVector2): number;
}
/**
 * 
 * @param translationScale 
 * @param angleScale    
 * @return 
 */
export interface physicsScaleGetter {
	(translationScale: CubismVector2, angleScale: number): number;
}
declare class CubismPhysicsInput {
	source: CubismPhysicsParameter;
	sourceParameterIndex: number;
	weight: number;
	type: number;
	reflect: boolean;
	getNormalizedParameterValue: normalizedPhysicsParameterValueGetter;
}
declare class CubismPhysicsOutput {
	destination: CubismPhysicsParameter;
	destinationParameterIndex: number;
	vertexIndex: number;
	translationScale: CubismVector2;
	angleScale: number;
	weight: number;
	type: CubismPhysicsSource;
	reflect: boolean;
	valueBelowMinimum: number;
	valueExceededMaximum: number;
	getValue: physicsValueGetter;
	getScale: physicsScaleGetter;
}
declare class CubismPhysicsRig {
	constructor();
	subRigCount: number;
	settings: CubismPhysicsSubRig[];
	inputs: CubismPhysicsInput[];
	outputs: CubismPhysicsOutput[];
	particles: CubismPhysicsParticle[];
	gravity: CubismVector2;
	wind: CubismVector2;
}
declare class CubismPhysics {
	/**
	 * 
	 * @param json    physics3.json
	 * @return 
	 */
	static create(json: CubismSpec.PhysicsJSON): CubismPhysics;
	/**
	 * 
	 * @param model 
	 * @param deltaTimeSeconds []
	 */
	evaluate(model: CubismModel, deltaTimeSeconds: number): void;
	/**
	 * 
	 * @param options 
	 */
	setOptions(options: Options): void;
	/**
	 * 
	 * @return 
	 */
	getOption(): Options;
	/**
	 * 
	 */
	constructor();
	/**
	 * 
	 */
	release(): void;
	/**
	 * physics3.json
	 * @param physicsJson physics3.json
	 */
	parse(physicsJson: CubismSpec.PhysicsJSON): void;
	/**
	 * 
	 */
	initialize(): void;
	_physicsRig: CubismPhysicsRig;
	_options: Options;
}
declare class Options {
	constructor();
	gravity: CubismVector2;
	wind: CubismVector2;
}
declare class csmRect {
	/**
	 * 
	 * @param x X
	 * @param y Y
	 * @param w 
	 * @param h 
	 */
	constructor(x?: number, y?: number, w?: number, h?: number);
	/**
	 * X
	 */
	getCenterX(): number;
	/**
	 * Y
	 */
	getCenterY(): number;
	/**
	 * X
	 */
	getRight(): number;
	/**
	 * Y
	 */
	getBottom(): number;
	/**
	 * 
	 * @param r 
	 */
	setRect(r: csmRect): void;
	/**
	 * 
	 * @param w 
	 * @param h 
	 */
	expand(w: number, h: number): void;
	x: number;
	y: number;
	width: number;
	height: number;
}
declare class CubismClippingManager_WebGL {
	/**
	 * RGBA
	 * @param channelNo RGBA0:R, 1:G, 2:B, 3:A
	 */
	getChannelFlagAsColor(channelNo: number): CubismTextureColor;
	/**
	 * 
	 * FrameBufferObject
	 *
	 * @return 
	 */
	getMaskRenderTexture(): WebGLFramebuffer | null;
	/**
	 * WebGL
	 * @param gl WebGL
	 */
	setGL(gl: WebGLRenderingContext): void;
	/**
	 * 
	 * @param model 
	 * @param clippingContext 
	 */
	calcClippedDrawTotalBounds(model: CubismModel, clippingContext: CubismClippingContext): void;
	/**
	 * 
	 */
	constructor();
	/**
	 * 
	 */
	release(): void;
	/**
	 * 
	 * 
	 * @param model 
	 * @param drawableCount 
	 * @param drawableMasks 
	 * @param drawableCounts 
	 */
	initialize(model: CubismModel, drawableCount: number, drawableMasks: Int32Array[], drawableMaskCounts: Int32Array): void;
	/**
	 * 
	 * @param model 
	 * @param renderer 
	 */
	setupClippingContext(model: CubismModel, renderer: CubismRenderer_WebGL): void;
	/**
	 * 
	 * 
	 * NULL
	 * @param drawableMasks 
	 * @param drawableMaskCounts 
	 * @return NULL
	 */
	findSameClip(drawableMasks: Int32Array, drawableMaskCounts: number): CubismClippingContext | null;
	/**
	 * 
	 * 
	 * 4RGBA56RGBA2,2,1,1
	 *
	 * @param usingClipCount 
	 */
	setupLayoutBounds(usingClipCount: number): void;
	/**
	 * 
	 * @return 
	 */
	getColorBuffer(): WebGLTexture | null;
	/**
	 * 
	 * @return 
	 */
	getClippingContextListForDraw(): (CubismClippingContext | null)[];
	/**
	 * 
	 * @param size 
	 */
	setClippingMaskBufferSize(size: number): void;
	/**
	 * 
	 * @return 
	 */
	getClippingMaskBufferSize(): number;
	_maskRenderTexture: WebGLFramebuffer | null;
	_colorBuffer: WebGLTexture | null;
	_currentFrameNo: number;
	_channelColors: CubismTextureColor[];
	_maskTexture?: CubismRenderTextureResource;
	_clippingContextListForMask: CubismClippingContext[];
	_clippingContextListForDraw: (CubismClippingContext | null)[];
	_clippingMaskBufferSize: number;
	private _tmpMatrix;
	private _tmpMatrixForMask;
	private _tmpMatrixForDraw;
	private _tmpBoundsOnModel;
	gl: WebGLRenderingContext;
}
declare class CubismRenderTextureResource {
	/**
	 * 
	 * @param frameNo 
	 * @param texture 
	 */
	constructor(frameNo: number, texture: WebGLFramebuffer | null);
	frameNo: number;
	texture: WebGLFramebuffer | null;
}
declare class CubismClippingContext {
	/**
	 * 
	 */
	constructor(manager: CubismClippingManager_WebGL, clippingDrawableIndices: Int32Array, clipCount: number);
	/**
	 * 
	 */
	release(): void;
	/**
	 * 
	 *
	 * @param drawableIndex 
	 */
	addClippedDrawable(drawableIndex: number): void;
	/**
	 * 
	 * @return 
	 */
	getClippingManager(): CubismClippingManager_WebGL;
	setGl(gl: WebGLRenderingContext): void;
	_isUsing: boolean;
	readonly _clippingIdList: Int32Array;
	_clippingIdCount: number;
	_layoutChannelNo: number;
	_layoutBounds: csmRect;
	_allClippedDrawRect: csmRect;
	_matrixForMask: CubismMatrix44;
	_matrixForDraw: CubismMatrix44;
	_clippedDrawableIndexList: number[];
	private _owner;
}
declare class CubismRenderer_WebGL extends CubismRenderer {
	/**
	 * 
	 * 
	 *
	 * @param model 
	 */
	initialize(model: CubismModel): void;
	/**
	 * WebGL
	 * CubismRendererCubismRendererIndex
	 * @param modelTextureNo 
	 * @param glTextureNo WebGL
	 */
	bindTexture(modelTextureNo: number, glTexture: WebGLTexture): void;
	/**
	 * WebGL
	 * @return 
	 */
	getBindedTextures(): Record<number, WebGLTexture>;
	/**
	 * 
	 * FrameBuffer
	 * @param size 
	 */
	setClippingMaskBufferSize(size: number): void;
	/**
	 * 
	 * @return 
	 */
	getClippingMaskBufferSize(): number;
	/**
	 * 
	 */
	constructor();
	/**
	 * 
	 */
	release(): void;
	/**
	 * 
	 */
	doDrawModel(): void;
	/**
	 * []
	 * 
	 * 
	 * @param textureNo 
	 * @param indexCount 
	 * @param vertexCount 
	 * @param indexArray 
	 * @param vertexArray 
	 * @param uvArray uv
	 * @param opacity 
	 * @param colorBlendMode 
	 * @param invertedMask 
	 */
	drawMesh(textureNo: number, indexCount: number, vertexCount: number, indexArray: Uint16Array, vertexArray: Float32Array, uvArray: Float32Array, opacity: number, colorBlendMode: CubismBlendMode, invertedMask: boolean): void;
	/**
	 * 
	 * WebGL
	 */
	static doStaticRelease(): void;
	/**
	 * 
	 * @param fbo 
	 * @param viewport 
	 */
	setRenderState(fbo: WebGLFramebuffer, viewport: number[]): void;
	/**
	 * 
	 * 
	 */
	preDraw(): void;
	/**
	 * 
	 */
	setClippingContextBufferForMask(clip: CubismClippingContext | null): void;
	/**
	 * 
	 * @return 
	 */
	getClippingContextBufferForMask(): CubismClippingContext | null;
	/**
	 * 
	 */
	setClippingContextBufferForDraw(clip: CubismClippingContext | null): void;
	/**
	 * 
	 * @return 
	 */
	getClippingContextBufferForDraw(): CubismClippingContext | null;
	/**
	 * gl
	 */
	startUp(gl: WebGLRenderingContext): void;
	_textures: Record<number, WebGLTexture>;
	_sortedDrawableIndexList: number[];
	_clippingManager: CubismClippingManager_WebGL;
	_clippingContextBufferForMask: CubismClippingContext | null;
	_clippingContextBufferForDraw: CubismClippingContext | null;
	firstDraw: boolean;
	_bufferData: {
		vertex: WebGLBuffer | null;
		uv: WebGLBuffer | null;
		index: WebGLBuffer | null;
	};
	gl: WebGLRenderingContext;
}
export declare class Cubism4InternalModel extends InternalModel {
	settings: Cubism4ModelSettings;
	coreModel: CubismModel;
	motionManager: Cubism4MotionManager;
	lipSync: boolean;
	breath: CubismBreath;
	eyeBlink?: CubismEyeBlink;
	pose?: CubismPose;
	physics?: CubismPhysics;
	userData?: CubismModelUserData;
	renderer: CubismRenderer_WebGL;
	idParamAngleX: string;
	idParamAngleY: string;
	idParamAngleZ: string;
	idParamEyeBallX: string;
	idParamEyeBallY: string;
	idParamBodyAngleX: string;
	idParamBreath: string;
	idParamMouthForm: string;
	/**
	 * The model's internal scale, defined in the moc3 file.
	 */
	readonly pixelsPerUnit: number;
	/**
	 * Matrix that scales by {@link pixelsPerUnit}, and moves the origin from top-left to center.
	 *
	 * FIXME: This shouldn't be named as "centering"...
	 */
	protected centeringTransform: Matrix;
	constructor(coreModel: CubismModel, settings: Cubism4ModelSettings, options?: InternalModelOptions);
	protected init(): void;
	protected getSize(): [
		number,
		number
	];
	protected getLayout(): CommonLayout;
	protected setupLayout(): void;
	updateWebGLContext(gl: WebGLRenderingContext, glContextID: number): void;
	bindTexture(index: number, texture: WebGLTexture): void;
	protected getHitAreaDefs(): CommonHitArea[];
	getDrawableIDs(): string[];
	getDrawableIndex(id: string): number;
	getDrawableVertices(drawIndex: number | string): Float32Array;
	updateTransform(transform: Matrix): void;
	update(dt: DOMHighResTimeStamp, now: DOMHighResTimeStamp): void;
	updateFocus(): void;
	updateFacialEmotion(mouthForm: number): void;
	updateNaturalMovements(dt: DOMHighResTimeStamp, now: DOMHighResTimeStamp): void;
	draw(gl: WebGLRenderingContext): void;
	destroy(): void;
}
export interface CubismStartupOption {
	logFunction: Live2DCubismCore.csmLogFunction;
	loggingLevel: LogLevel;
}
declare enum LogLevel {
	LogLevel_Verbose = 0,
	LogLevel_Debug = 1,
	LogLevel_Info = 2,
	LogLevel_Warning = 3,
	LogLevel_Error = 4,
	LogLevel_Off = 5
}
/**
 * Promises that the Cubism 4 framework is ready to work.
 * @return Promise that resolves if the startup has succeeded, rejects if failed.
 */
export declare function cubism4Ready(): Promise<void>;
/**
 * Starts up Cubism 4 framework.
 */
export declare function startUpCubism4(options?: CubismStartupOption): void;

export {};
